#version 460

#include "common.glsl"
#include "include/brick_formats.glsl"

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
layout(set = 0, binding = 1,  rgba16f) uniform writeonly image2D accumImage;
layout(set = 0, binding = 15, rgba16f) uniform writeonly image2D motionImage;
layout(set = 0, binding = 18, rgba16f) uniform writeonly image2D albedoImage;
layout(set = 0, binding = 19, rgba16f) uniform writeonly image2D normalImage;
layout(set = 0, binding = 20, rgba16f) uniform writeonly image2D momentsImage;

layout(set = 0, binding = 24, std430) readonly buffer MaterialTableBuf {
  MaterialGpu materials[];
};

struct QueueHeader {
  uint head;
  uint tail;
  uint capacity;
  uint dropped;
};

struct HitPayload {
  vec3  position;
  float t;
  vec3  normal;
  uint  material;
  vec3  direction;
  uint  rng;
  uint  pixelIndex;
  uint  pathDepth;
};

struct MissPayload {
  vec3  origin;
  float tMin;
  vec3  direction;
  float tMax;
  uint  rng;
  uint  pixelIndex;
  uint  pathDepth;
  uint  reason;
};

layout(set = 0, binding = 11, std430) buffer HitQueueBuf {
  QueueHeader header;
  HitPayload  hits[];
} HitQueue;

layout(set = 0, binding = 12, std430) buffer MissQueueBuf {
  QueueHeader header;
  MissPayload misses[];
} MissQueue;

bool dequeueHit(out HitPayload hit) {
  for (;;) {
    uint idx = atomicAdd(HitQueue.header.head, 1u);
    uint tail = HitQueue.header.tail;
    if (idx < tail) {
      uint slot = idx & (HitQueue.header.capacity - 1u);
      hit = HitQueue.hits[slot];
      return true;
    }
    atomicAdd(HitQueue.header.head, uint(0u - 1u));
    if (idx >= tail) return false;
  }
}

bool dequeueMiss(out MissPayload miss) {
  for (;;) {
    uint idx = atomicAdd(MissQueue.header.head, 1u);
    uint tail = MissQueue.header.tail;
    if (idx < tail) {
      uint slot = idx & (MissQueue.header.capacity - 1u);
      miss = MissQueue.misses[slot];
      return true;
    }
    atomicAdd(MissQueue.header.head, uint(0u - 1u));
    if (idx >= tail) return false;
  }
}

ivec2 pixelFromIndex(uint idx) {
  uint w = max(g.width, 1u);
  uint x = idx % w;
  uint y = idx / w;
  return ivec2(int(x), int(y));
}

vec3 shadeHit(const HitPayload hit, vec3 worldPos, MaterialGpu mat) {
  vec3 baseColor = mat.baseColorRoughness.rgb;
  float roughness = clamp(mat.baseColorRoughness.a, 0.04, 1.0);
  float emission = mat.emissionMetalnessPad.x;
  float metalness = clamp(mat.emissionMetalnessPad.y, 0.0, 1.0);

  vec3 n = normalize(hit.normal);
  vec3 lightDir = normalize(vec3(0.35, 0.6, 0.65));
  vec3 viewDir = normalize(-hit.direction);
  vec3 halfDir = normalize(lightDir + viewDir);
  float ndotl = max(dot(n, lightDir), 0.0);
  float ndotv = max(dot(n, viewDir), 0.0);
  float ndoth = max(dot(n, halfDir), 0.0);
  float vdoth = max(dot(viewDir, halfDir), 0.0);

  vec3 F0 = mix(vec3(0.04), baseColor, metalness);
  float alpha = roughness * roughness;
  float denom = ndoth * ndoth * (alpha * alpha - 1.0) + 1.0;
  float D = (alpha * alpha) / max(3.14159265 * denom * denom, 1e-4);
  float k = (roughness + 1.0);
  k = (k * k) / 8.0;
  float Gv = ndotv / max(ndotv * (1.0 - k) + k, 1e-4);
  float Gl = ndotl / max(ndotl * (1.0 - k) + k, 1e-4);
  float G = Gv * Gl;
  vec3 F = F0 + (1.0 - F0) * pow(1.0 - vdoth, 5.0);
  vec3 specular = (D * G) * F / max(4.0 * ndotv * ndotl, 1e-4);

  vec3 diffuseColor = (1.0 - metalness) * baseColor / 3.14159265;
  vec3 diffuse = diffuseColor * ndotl;

  float lightIntensity = 2.2;
  vec3 ambient = baseColor * 0.12;
  vec3 color = ambient + lightIntensity * (diffuse + specular);
  color += emission;
  return max(color, vec3(0.0));
}

vec3 shadeMiss(const MissPayload miss) {
  vec3 dir = normalize(miss.direction);
  float v = clamp(0.5 * (dir.y + 1.0), 0.0, 1.0);
  vec3 top = vec3(0.25, 0.45, 0.9);
  vec3 bottom = vec3(0.85, 0.9, 1.0);
  return mix(bottom, top, pow(v, 1.5));
}

vec2 clipToScreen(vec4 clip) {
  float invW = (abs(clip.w) > 1e-6) ? (1.0 / clip.w) : 0.0;
  vec2 ndc = clip.xy * invW;
  return ndc * 0.5 + 0.5;
}

vec2 computeMotion(vec3 worldPos) {
  vec4 currClip = g.currProj * (g.currView * vec4(worldPos, 1.0));
  if (abs(currClip.w) <= 1e-6) return vec2(0.0);
  vec2 currScreen = clipToScreen(currClip);

  vec4 prevClip = g.prevProj * (g.prevView * vec4(worldPos, 1.0));
  if (abs(prevClip.w) <= 1e-6) return vec2(0.0);
  vec2 prevScreen = clipToScreen(prevClip);

  return currScreen - prevScreen;
}

void writeOutputs(ivec2 pix, vec3 color, vec2 velocity, float valid) {
  if (pix.x < 0 || pix.y < 0 || pix.x >= int(g.width) || pix.y >= int(g.height)) return;
  imageStore(accumImage, pix, vec4(color, 1.0));
  imageStore(motionImage, pix, vec4(velocity, valid, 0.0));
}

void writeGBuffer(ivec2 pix, vec3 albedo, vec3 normal, float depth, float moment1, float moment2, float valid) {
  if (pix.x < 0 || pix.y < 0 || pix.x >= int(g.width) || pix.y >= int(g.height)) return;
  imageStore(albedoImage, pix, vec4(albedo, 1.0));
  imageStore(normalImage, pix, vec4(normal * 0.5 + 0.5, depth));
  imageStore(momentsImage, pix, vec4(moment1, moment2, depth, valid));
}

void main() {
  for (;;) {
    HitPayload hit;
    if (dequeueHit(hit)) {
      ivec2 pix = pixelFromIndex(hit.pixelIndex);
      vec3 worldPos = hit.position + g.renderOrigin;
      vec2 velocity = computeMotion(worldPos);
      uint count = materials.length();
      uint matIndex = (count > 0u) ? min(hit.material, count - 1u) : 0u;
      MaterialGpu mat = materials[matIndex];
      vec3 color = shadeHit(hit, worldPos, mat);
      vec3 baseColor = mat.baseColorRoughness.rgb;
      float roughness = clamp(mat.baseColorRoughness.a, 0.04, 1.0);
      float metalness = clamp(mat.emissionMetalnessPad.y, 0.0, 1.0);
      float luminance = dot(color, vec3(0.299, 0.587, 0.114));
      if (dispatch.bounceIndex == 0u) {
        writeGBuffer(pix,
                     baseColor,
                     normalize(hit.normal),
                     hit.t,
                     luminance,
                     luminance * luminance,
                     1.0);
      }
      writeOutputs(pix, color, velocity, 1.0);
      continue;
    }
    MissPayload miss;
    if (dequeueMiss(miss)) {
      vec3 color = shadeMiss(miss);
      ivec2 pix = pixelFromIndex(miss.pixelIndex);
      if (dispatch.bounceIndex == 0u) {
        writeGBuffer(pix,
                     vec3(0.0),
                     vec3(0.0, 0.0, 1.0),
                     0.0,
                     0.0,
                     0.0,
                     0.0);
      }
      writeOutputs(pix, color, vec2(0.0), 0.0);
      continue;
    }
    break;
  }
}
