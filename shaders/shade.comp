#version 460

#include "common.glsl"
#include "include/brick_formats.glsl"

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
layout(set = 0, binding = 1,  rgba16f) uniform image2D accumImage;
layout(set = 0, binding = 15, rgba16f) uniform writeonly image2D motionImage;
layout(set = 0, binding = 18, rgba16f) uniform writeonly image2D albedoImage;
layout(set = 0, binding = 19, rgba16f) uniform writeonly image2D normalImage;
layout(set = 0, binding = 20, rgba16f) uniform writeonly image2D momentsImage;

layout(set = 0, binding = 24, std430) readonly buffer MaterialTableBuf {
  MaterialGpu materials[];
};

struct RayPayload {
  vec3  origin;
  float tMin;
  vec3  direction;
  float tMax;
  vec3  throughput;
  float padThroughput;
  uint  rng;
  uint  pixelIndex;
  uint  pathDepth;
  uint  flags;
};

struct QueueHeader {
  uint head;
  uint tail;
  uint capacity;
  uint dropped;
};

struct HitPayload {
  vec3  position;
  float t;
  vec3  normal;
  uint  material;
  vec3  direction;
  uint  rng;
  uint  pixelIndex;
  uint  pathDepth;
  vec3  throughput;
  float padThroughput;
};

struct MissPayload {
  vec3  origin;
  float tMin;
  vec3  direction;
  float tMax;
  vec3  throughput;
  float padThroughput;
  uint  rng;
  uint  pixelIndex;
  uint  pathDepth;
  uint  reason;
};

layout(set = 0, binding = 10, std430) buffer RayQueueBuf {
  QueueHeader header;
  RayPayload rays[];
} RayQueueIn;

layout(set = 0, binding = 11, std430) buffer HitQueueBuf {
  QueueHeader header;
  HitPayload  hits[];
} HitQueue;

layout(set = 0, binding = 12, std430) buffer MissQueueBuf {
  QueueHeader header;
  MissPayload misses[];
} MissQueue;

layout(set = 0, binding = 13, std430) buffer SecondaryQueueBuf {
  QueueHeader header;
  RayPayload rays[];
} SecondaryQueue;

uint reserveRaySlotPrimary() {
  uint slot = atomicAdd(RayQueueIn.header.tail, 1u);
  uint capacity = RayQueueIn.header.capacity;
  if (capacity == 0u) {
    atomicAdd(RayQueueIn.header.dropped, 1u);
    return 0u;
  }
  uint headSnapshot = RayQueueIn.header.head;
  if ((slot - headSnapshot) >= capacity) {
    atomicAdd(RayQueueIn.header.dropped, 1u);
    slot = headSnapshot;
  }
  return slot & (capacity - 1u);
}

uint reserveRaySlotSecondary() {
  uint slot = atomicAdd(SecondaryQueue.header.tail, 1u);
  uint capacity = SecondaryQueue.header.capacity;
  if (capacity == 0u) {
    atomicAdd(SecondaryQueue.header.dropped, 1u);
    return 0u;
  }
  uint headSnapshot = SecondaryQueue.header.head;
  if ((slot - headSnapshot) >= capacity) {
    atomicAdd(SecondaryQueue.header.dropped, 1u);
    slot = headSnapshot;
  }
  return slot & (capacity - 1u);
}

void enqueueRayPayload(RayPayload payload) {
  if (dispatch.queueDst == 0u) {
    uint slot = reserveRaySlotPrimary();
    RayQueueIn.rays[slot] = payload;
  } else {
    uint slot = reserveRaySlotSecondary();
    SecondaryQueue.rays[slot] = payload;
  }
}

bool dequeueHit(out HitPayload hit) {
  for (;;) {
    uint idx = atomicAdd(HitQueue.header.head, 1u);
    uint tail = HitQueue.header.tail;
    if (idx < tail) {
      uint slot = idx & (HitQueue.header.capacity - 1u);
      hit = HitQueue.hits[slot];
      return true;
    }
    atomicAdd(HitQueue.header.head, uint(0u - 1u));
    if (idx >= tail) return false;
  }
}

bool dequeueMiss(out MissPayload miss) {
  for (;;) {
    uint idx = atomicAdd(MissQueue.header.head, 1u);
    uint tail = MissQueue.header.tail;
    if (idx < tail) {
      uint slot = idx & (MissQueue.header.capacity - 1u);
      miss = MissQueue.misses[slot];
      return true;
    }
    atomicAdd(MissQueue.header.head, uint(0u - 1u));
    if (idx >= tail) return false;
  }
}

ivec2 pixelFromIndex(uint idx) {
  uint w = max(g.width, 1u);
  uint x = idx % w;
  uint y = idx / w;
  return ivec2(int(x), int(y));
}

vec3 cosineSampleHemisphere(inout uint rng, vec3 normal) {
  vec2 xi = rand2(rng);
  float phi = 6.28318530718 * xi.x;
  float cosTheta = sqrt(1.0 - xi.y);
  float sinTheta = sqrt(xi.y);
  vec3 tangent = normalize(abs(normal.z) < 0.999f ? cross(vec3(0.0, 0.0, 1.0), normal)
                                                  : cross(vec3(0.0, 1.0, 0.0), normal));
  vec3 bitangent = cross(normal, tangent);
  vec3 local = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
  return normalize(tangent * local.x + bitangent * local.y + normal * local.z);
}

vec3 shadeHit(const HitPayload hit, vec3 worldPos, MaterialGpu mat, out vec3 outAlbedo) {
  vec3 baseColor = mat.baseColorRoughness.rgb;
  float roughness = clamp(mat.baseColorRoughness.a, 0.04, 1.0);
  float emission = mat.emissionMetalnessPad.x;
  float metalness = clamp(mat.emissionMetalnessPad.y, 0.0, 1.0);

  vec3 n = normalize(hit.normal);
  vec3 lightDir = normalize(vec3(0.35, 0.6, 0.65));
  vec3 viewDir = normalize(-hit.direction);
  vec3 halfDir = normalize(lightDir + viewDir);
  float ndotl = max(dot(n, lightDir), 0.0);
  float ndotv = max(dot(n, viewDir), 0.0);
  float ndoth = max(dot(n, halfDir), 0.0);
  float vdoth = max(dot(viewDir, halfDir), 0.0);

  vec3 F0 = mix(vec3(0.04), baseColor, metalness);
  float alpha = roughness * roughness;
  float denom = ndoth * ndoth * (alpha * alpha - 1.0) + 1.0;
  float D = (alpha * alpha) / max(3.14159265 * denom * denom, 1e-4);
  float k = (roughness + 1.0);
  k = (k * k) / 8.0;
  float Gv = ndotv / max(ndotv * (1.0 - k) + k, 1e-4);
  float Gl = ndotl / max(ndotl * (1.0 - k) + k, 1e-4);
  float G = Gv * Gl;
  vec3 F = F0 + (1.0 - F0) * pow(1.0 - vdoth, 5.0);
  vec3 specular = (D * G) * F / max(4.0 * ndotv * ndotl, 1e-4);

  vec3 diffuseColor = (1.0 - metalness) * baseColor / 3.14159265;
  vec3 diffuse = diffuseColor * ndotl;

  float lightIntensity = 2.2;
  vec3 ambient = baseColor * 0.12;
  vec3 color = ambient + lightIntensity * (diffuse + specular);
  color += emission;
  outAlbedo = baseColor;
  return max(color, vec3(0.0));
}

vec3 shadeMiss(const MissPayload miss) {
  vec3 dir = normalize(miss.direction);
  float v = clamp(0.5 * (dir.y + 1.0), 0.0, 1.0);
  vec3 top = vec3(0.25, 0.45, 0.9);
  vec3 bottom = vec3(0.85, 0.9, 1.0);
  return mix(bottom, top, pow(v, 1.5));
}

void accumulateColor(ivec2 pix, vec3 color) {
  if (pix.x < 0 || pix.y < 0 || pix.x >= int(g.width) || pix.y >= int(g.height)) return;
  if (dispatch.bounceIndex == 0u) {
    imageStore(accumImage, pix, vec4(color, 1.0));
  } else {
    vec4 prev = imageLoad(accumImage, pix);
    imageStore(accumImage, pix, vec4(prev.rgb + color, 1.0));
  }
}

vec2 clipToScreen(vec4 clip) {
  float invW = (abs(clip.w) > 1e-6) ? (1.0 / clip.w) : 0.0;
  vec2 ndc = clip.xy * invW;
  return ndc * 0.5 + 0.5;
}

vec2 computeMotion(vec3 worldPos) {
  vec4 currClip = g.currProj * (g.currView * vec4(worldPos, 1.0));
  if (abs(currClip.w) <= 1e-6) return vec2(0.0);
  vec2 currScreen = clipToScreen(currClip);

  vec4 prevClip = g.prevProj * (g.prevView * vec4(worldPos, 1.0));
  if (abs(prevClip.w) <= 1e-6) return vec2(0.0);
  vec2 prevScreen = clipToScreen(prevClip);

  return currScreen - prevScreen;
}

void writeOutputs(ivec2 pix, vec2 velocity, float valid) {
  if (pix.x < 0 || pix.y < 0 || pix.x >= int(g.width) || pix.y >= int(g.height)) return;
  if (dispatch.bounceIndex == 0u) {
    imageStore(motionImage, pix, vec4(velocity, valid, 0.0));
  }
}

void writeGBuffer(ivec2 pix, vec3 albedo, vec3 normal, float depth, float moment1, float moment2, float valid) {
  if (pix.x < 0 || pix.y < 0 || pix.x >= int(g.width) || pix.y >= int(g.height)) return;
  imageStore(albedoImage, pix, vec4(albedo, 1.0));
  imageStore(normalImage, pix, vec4(normal * 0.5 + 0.5, depth));
  imageStore(momentsImage, pix, vec4(moment1, moment2, depth, valid));
}

void main() {
  for (;;) {
    HitPayload hit;
    if (dequeueHit(hit)) {
      ivec2 pix = pixelFromIndex(hit.pixelIndex);
      vec3 worldPos = hit.position + g.renderOrigin;
      vec2 velocity = computeMotion(worldPos);
      uint count = materials.length();
      uint matIndex = (count > 0u) ? min(hit.material, count - 1u) : 0u;
      MaterialGpu mat = materials[matIndex];
      vec3 albedo;
      vec3 direct = shadeHit(hit, worldPos, mat, albedo);
      vec3 throughput = hit.throughput;
      vec3 color = throughput * direct;
      float luminance = dot(color, vec3(0.299, 0.587, 0.114));
      accumulateColor(pix, color);
      if (dispatch.bounceIndex == 0u) {
        writeGBuffer(pix,
                     albedo,
                     normalize(hit.normal),
                     hit.t,
                     luminance,
                     luminance * luminance,
                     1.0);
      }
      writeOutputs(pix, velocity, 1.0);

      if (hit.pathDepth + 1u < g.maxBounces && any(greaterThan(hit.throughput, vec3(1e-4)))) {
        RayPayload next;
        vec3 normal = normalize(hit.normal);
        vec3 origin = hit.position + normal * g.voxelSize;
        uint rng = hit.rng;
        vec3 bounceDir = cosineSampleHemisphere(rng, normal);
        next.origin = origin;
        next.tMin = 0.01;
        next.direction = bounceDir;
        next.tMax = g.Rout * 4.0;
        vec3 bounceThroughput = throughput * max(albedo, vec3(0.0));
        next.throughput = bounceThroughput;
        next.padThroughput = 0.0;
        next.rng = rng;
        next.pixelIndex = hit.pixelIndex;
        next.pathDepth = hit.pathDepth + 1u;
        next.flags = 0u;
        if (any(greaterThan(bounceThroughput, vec3(1e-4)))) {
          enqueueRayPayload(next);
        }
      }
      continue;
    }
    MissPayload miss;
    if (dequeueMiss(miss)) {
      vec3 color = shadeMiss(miss);
      ivec2 pix = pixelFromIndex(miss.pixelIndex);
      vec3 shadedMiss = miss.throughput * color;
      accumulateColor(pix, shadedMiss);
      if (dispatch.bounceIndex == 0u) {
        writeGBuffer(pix,
                     vec3(0.0),
                     vec3(0.0, 0.0, 1.0),
                     0.0,
                     0.0,
                     0.0,
                     0.0);
      }
      writeOutputs(pix, vec2(0.0), 0.0);
      continue;
    }
    break;
  }
}
