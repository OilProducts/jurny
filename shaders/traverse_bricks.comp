#version 460

#extension GL_ARB_gpu_shader_int64 : enable

#include "common.glsl"
#include "spherical.glsl"
#include "include/brick_formats.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform GlobalsUBO { GlobalsUBO_t g; };
layout(set = 0, binding = 1, rgba8) uniform writeonly image2D accumImage;
layout(set = 0, binding = 3, std430) readonly buffer BrickHeadersBuf { BrickHeader headers[]; } BH;
layout(set = 0, binding = 4, std430) readonly buffer OccupancyBuf   { uint64_t  occWords[]; } OCC;
layout(set = 0, binding = 5, std430) readonly buffer HashKeysBuf    { uint64_t  keys[];     } HK;
layout(set = 0, binding = 6, std430) readonly buffer HashValsBuf    { uint      vals[];     } HV;
layout(set = 0, binding = 7, std430) readonly buffer MacroKeysBuf   { uint64_t  mkeys[];    } MK;
layout(set = 0, binding = 8, std430) readonly buffer MacroValsBuf   { uint      mvals[];    } MV;

// Simple hash find (linear probe), capacity from UBO
bool findBrick(ivec3 bc, out uint brickIdx) {
  const uint B = 1u<<20; // bias
  uint64_t key = (uint64_t(bc.x + int(B)) << 42) | (uint64_t(bc.y + int(B)) << 21) | uint64_t(bc.z + int(B));
  uint cap = g.worldHashCapacity; if (cap == 0u) return false;
  uint mask = cap - 1u;
  // Use the same 64->32 mix as CPU builder: h = ((key ^ (key>>33)) * 0xff51afd7ed558ccd) >> 32
  uint64_t kx = key ^ (key >> 33u);
  const uint64_t A = (uint64_t(0xff51afd7u) << 32) | uint64_t(0xed558ccdu);
  uint64_t mix = kx * A;
  uint h = uint(mix >> 32) & mask;
  for (uint i=0u; i<cap; ++i) {
    uint idx = (h + i) & mask;
    uint64_t k = HK.keys[idx];
    if (k == key) { brickIdx = HV.vals[idx]; return true; }
    if (k == 0ul) break;
  }
  return false;
}

bool findMacro(ivec3 mc) {
  const uint B = 1u<<20; uint64_t key = (uint64_t(mc.x + int(B)) << 42) | (uint64_t(mc.y + int(B)) << 21) | uint64_t(mc.z + int(B));
  uint cap = g.macroHashCapacity; if (cap == 0u) return false; uint mask = cap - 1u;
  uint64_t kx = key ^ (key >> 33u); const uint64_t A = (uint64_t(0xff51afd7u) << 32) | uint64_t(0xed558ccdu);
  uint h = uint((kx * A) >> 32) & mask;
  for (uint i=0u;i<cap;++i) { uint idx=(h+i)&mask; uint64_t k=MK.mkeys[idx]; if (k==key) return (MV.mvals[idx]!=0u); if (k==0ul) break; }
  return false;
}

bool rayAABB(vec3 ro, vec3 rd, vec3 bmin, vec3 bmax, out float t0, out float t1) {
  vec3 inv = 1.0 / rd;
  vec3 tA = (bmin - ro) * inv;
  vec3 tB = (bmax - ro) * inv;
  vec3 tmin = min(tA, tB);
  vec3 tmax = max(tA, tB);
  t0 = max(0.0, max(tmin.x, max(tmin.y, tmin.z)));
  t1 = max(t0, min(tmax.x, min(tmax.y, tmax.z)));
  return t1 > t0;
}

bool brickIsEmpty(uint baseWord) {
  // 8 words per brick
  for (int i=0;i<8;++i) if (OCC.occWords[baseWord + i] != 0ul) return false;
  return true;
}

bool sampleOcc(in BrickHeader h, in vec3 p) {
  // Convert world p to local voxel indices
  vec3 brickOrigin = vec3(h.bx, h.by, h.bz) * g.brickSize;
  vec3 lp = (p - brickOrigin) / g.voxelSize;
  ivec3 v = ivec3(floor(lp));
  if (any(lessThan(v, ivec3(0))) || any(greaterThan(v, ivec3(7)))) return false;
  uint idx = uint(v.x + v.y*uint(VOXEL_BRICK_SIZE) + v.z*uint(VOXEL_BRICK_SIZE*VOXEL_BRICK_SIZE));
  uint w = idx >> 6; uint b = idx & 63u;
  uint baseWord = h.occOffset / 8u; // bytes -> uint64 index
  return ((OCC.occWords[baseWord + w] >> b) & 1ul) != 0ul;
}

void makeRay(in ivec2 pix, out vec3 ro, out vec3 rd) {
  ivec2 dims = imageSize(accumImage);
  vec2 uv = (vec2(pix) + vec2(0.5)) / vec2(dims);
  vec2 ndc = vec2(uv.x * 2.0 - 1.0, 1.0 - uv.y * 2.0);
  mat4 invV = inverse(g.currView);
  mat4 invP = inverse(g.currProj);
  ro = vec3(invV * vec4(0,0,0,1));
  vec4 pView = invP * vec4(ndc, 1.0, 1.0);
  pView /= max(pView.w, 1e-6);
  rd = normalize(vec3(invV * vec4(normalize(vec3(pView)), 0.0)));
}

void main() {
  ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
  ivec2 dims = imageSize(accumImage);
  if (pix.x >= dims.x || pix.y >= dims.y) return;

  vec3 ro, rd; makeRay(pix, ro, rd);

  // DEBUG OVERLAY: probe brick presence at the analytic sea-level sphere hit
  if ((g.flags & 1u) != 0u) {
    float t0, t1; vec3 color = vec3(0.0);
    if (intersectSphere(ro, rd, g.Rsea, t0, t1)) {
      float t = (t0 > 1e-6) ? t0 : ((t1 > 1e-6) ? t1 : 1e30);
      if (t < 1e20) {
        vec3 p = ro + t * rd;
        ivec3 bcProbe = ivec3(floor(p / g.brickSize));
        uint idx; bool found = findBrick(bcProbe, idx);
        color = found ? vec3(1.0, 0.1, 0.1) : vec3(0.1, 0.1, 0.6);
      } else {
        color = vec3(0.0, 0.0, 0.0);
      }
    } else {
      color = vec3(0.0, 0.0, 0.0);
    }
    imageStore(accumImage, pix, vec4(color, 1.0));
    return;
  }

  // DEBUG OVERLAY 2: show first coarse-DDA brick hit (yellow if any, blue sky otherwise)
  if ((g.flags & 2u) != 0u) {
    float tEnter, tExit; bool inShell = intersectSphereShell(ro, rd, g.Rin, g.Rout, tEnter, tExit);
    float tmin = inShell ? tEnter : 0.0; float tmax = inShell ? tExit : 50000.0;
    // Clamp traversal to a band around the near-side crust intersection to avoid far-hemisphere hits
    float s0, s1; if (intersectSphere(ro, rd, g.Rsea, s0, s1)) {
      float s = 1e30; if (s0>=tmin && s0<=tmax) s=min(s,s0); if (s1>=tmin && s1<=tmax) s=min(s,s1);
      if (s < 1e20) {
        float band = 8.0 * g.brickSize; // conservative band around surface
        float eps  = 1e-4 * g.brickSize;
        tmin = max(tEnter, s - band) + eps;
        tmax = min(tExit,  s + band);
      }
    }
    vec3 pos = ro + rd * tmin;
    ivec3 bc = ivec3(floor(pos / g.brickSize));
    vec3 cellMin = vec3(bc) * g.brickSize; vec3 cellMax = cellMin + vec3(g.brickSize);
    vec3 tDelta = vec3(g.brickSize) / abs(rd);
    vec3 tMax;
    tMax.x = (rd.x > 0.0) ? ((cellMax.x - pos.x) / rd.x) : ((pos.x - cellMin.x) / -rd.x);
    tMax.y = (rd.y > 0.0) ? ((cellMax.y - pos.y) / rd.y) : ((pos.y - cellMin.y) / -rd.y);
    tMax.z = (rd.z > 0.0) ? ((cellMax.z - pos.z) / rd.z) : ((pos.z - cellMin.z) / -rd.z);
    tMax += vec3(tmin);
    bool any=false;
    for (int stepCount=0; stepCount<4096 && tmin < tmax; ++stepCount) {
      uint bidx; if (findBrick(bc, bidx)) { any=true; break; }
      if (tMax.x <= tMax.y && tMax.x <= tMax.z) { tmin = tMax.x; bc.x += (rd.x>0.0)?1:-1; tMax.x += tDelta.x; }
      else if (tMax.y <= tMax.z) { tmin = tMax.y; bc.y += (rd.y>0.0)?1:-1; tMax.y += tDelta.y; }
      else { tmin = tMax.z; bc.z += (rd.z>0.0)?1:-1; tMax.z += tDelta.z; }
    }
    vec3 color = any ? vec3(1.0,1.0,0.2) : vec3(0.1,0.1,0.6);
    imageStore(accumImage, pix, vec4(color,1.0));
    return;
  }

  // Clamp traversal to shell to reduce brick steps
  float tEnter, tExit;
  bool inShell = intersectSphereShell(ro, rd, g.Rin, g.Rout, tEnter, tExit);
  float tmin = inShell ? tEnter : 0.0;
  float tmax = inShell ? tExit  : 50000.0; // fallback

  // Clamp traversal to a band around the near-side crust intersection; prevents seeing far hemisphere when near side is empty
  float s0n, s1n; if (intersectSphere(ro, rd, g.Rsea, s0n, s1n)) {
    float s = 1e30; if (s0n>=tmin && s0n<=tmax) s=min(s,s0n); if (s1n>=tmin && s1n<=tmax) s=min(s,s1n);
    if (s < 1e20) {
      float band = 8.0 * g.brickSize;
      float eps  = 1e-4 * g.brickSize;
      tmin = max(tEnter, s - band) + eps;
      tmax = min(tExit,  s + band);
    }
  }

  // Brick stepping (coarse 3D DDA). Start at shell (or sea-level) entry point.
  vec3 pos = ro + rd * (tmin + 1e-5 * g.brickSize); // nudge inside to avoid boundary ambiguity
  ivec3 bc = ivec3(floor(pos / g.brickSize));
  vec3 cellMin = vec3(bc) * g.brickSize;
  vec3 cellMax = cellMin + vec3(g.brickSize);
  vec3 tDelta = vec3(g.brickSize) / abs(rd);
  vec3 tMax;
  tMax.x = (rd.x > 0.0) ? ((cellMax.x - pos.x) / rd.x) : ((pos.x - cellMin.x) / -rd.x);
  tMax.y = (rd.y > 0.0) ? ((cellMax.y - pos.y) / rd.y) : ((pos.y - cellMin.y) / -rd.y);
  tMax.z = (rd.z > 0.0) ? ((cellMax.z - pos.z) / rd.z) : ((pos.z - cellMin.z) / -rd.z);
  tMax += vec3(tmin);

  vec3 colorSkyTop = vec3(0.25, 0.45, 0.9);
  vec3 colorSkyBot = vec3(0.85, 0.9, 1.0);
  vec3 color = vec3(0.0);
  bool shaded = false;

  for (int stepCount=0; stepCount<4096 && tmin < tmax; ++stepCount) {
    // Macro mask skipping (skip whole macro tiles if absent) â€” gated by flag bit 8
    if (((g.flags & 8u) != 0u) && (g.macroHashCapacity > 0u)) {
      float macroSize = g.macroSize;
      // Compute macro coords from current brick coords to avoid float boundary noise
      ivec3 mc = ivec3(floor(vec3(bc) / float(g.macroDimBricks)));
      if (!findMacro(mc)) {
        vec3 mMin = vec3(mc) * macroSize;
        vec3 mMax = mMin + vec3(macroSize);
        vec3 tMaxM;
        tMaxM.x = (rd.x > 0.0) ? ((mMax.x - pos.x) / rd.x) : ((pos.x - mMin.x) / -rd.x);
        tMaxM.y = (rd.y > 0.0) ? ((mMax.y - pos.y) / rd.y) : ((pos.y - mMin.y) / -rd.y);
        tMaxM.z = (rd.z > 0.0) ? ((mMax.z - pos.z) / rd.z) : ((pos.z - mMin.z) / -rd.z);
        float tNext = min(tMaxM.x, min(tMaxM.y, tMaxM.z));
        tmin = min(tmax, tmin + max(tNext, 0.0) + 1e-5 * g.brickSize);
        pos = ro + rd * tmin;
        bc = ivec3(floor(pos / g.brickSize));
        cellMin = vec3(bc) * g.brickSize; cellMax = cellMin + vec3(g.brickSize);
        tDelta = vec3(g.brickSize) / abs(rd);
        tMax.x = (rd.x > 0.0) ? ((cellMax.x - pos.x) / rd.x) : ((pos.x - cellMin.x) / -rd.x);
        tMax.y = (rd.y > 0.0) ? ((cellMax.y - pos.y) / rd.y) : ((pos.y - cellMin.y) / -rd.y);
        tMax.z = (rd.z > 0.0) ? ((cellMax.z - pos.z) / rd.z) : ((pos.z - cellMin.z) / -rd.z);
        tMax += vec3(tmin);
        continue;
      }
    }

    uint bidx = 0u;
    if (findBrick(bc, bidx)) {
      // If debug flag 4 set: shade immediately (coarse brick hit) to validate coarse DDA
      if ((g.flags & 4u) != 0u) {
        imageStore(accumImage, pix, vec4(1.0, 1.0, 0.2, 1.0));
        return;
      }
      BrickHeader h = BH.headers[bidx];
      uint baseWord = h.occOffset / 8u;
      if (!brickIsEmpty(baseWord)) {
        // Intersect ray with this brick AABB to limit search interval
        float tb0, tb1; vec3 bmin = vec3(h.bx, h.by, h.bz) * g.brickSize; vec3 bmax = bmin + vec3(g.brickSize);
        if (rayAABB(ro, rd, bmin, bmax, tb0, tb1)) {
          float t0 = max(tb0, tmin);
          float t1 = min(tb1, tmax);
          // Micro-DDA in voxel space
          vec3 p0 = ro + t0 * rd;
          vec3 lpos = (p0 - bmin) / g.voxelSize; // voxel units
          ivec3 v = ivec3(clamp(floor(lpos), vec3(0.0), vec3(float(VOXEL_BRICK_SIZE-1))));
          vec3 r = rd; vec3 invr = 1.0 / max(abs(r), vec3(1e-9));
          vec3 tDeltaV = g.voxelSize * invr;
          vec3 nextB;
          nextB.x = (r.x > 0.0) ? ((float(v.x)+1.0) - lpos.x) : (lpos.x - float(v.x));
          nextB.y = (r.y > 0.0) ? ((float(v.y)+1.0) - lpos.y) : (lpos.y - float(v.y));
          nextB.z = (r.z > 0.0) ? ((float(v.z)+1.0) - lpos.z) : (lpos.z - float(v.z));
          vec3 tMaxV = t0 + nextB * invr * g.voxelSize;
          float tCellEnter = t0;
          for (int iter=0; iter<128 && tCellEnter <= t1; ++iter) {
            uint idx = uint(v.x + v.y*uint(VOXEL_BRICK_SIZE) + v.z*uint(VOXEL_BRICK_SIZE*VOXEL_BRICK_SIZE));
            uint baseWord = h.occOffset / 8u; uint w = idx >> 6u; uint b = idx & 63u;
            bool occ = ((OCC.occWords[baseWord + w] >> b) & 1ul) != 0ul;
            float tCellExit = min(tMaxV.x, min(tMaxV.y, tMaxV.z));
            if (occ) {
              // refine within [tCellEnter, tCellExit]
              float ta = tCellEnter; float tb = tCellExit; float tm = tb;
              float fa = F_crust(ro + ta*rd, g.Rsea); float fb = F_crust(ro + tb*rd, g.Rsea);
              if (fa*fb <= 0.0) {
                for (int j=0;j<6;++j) { tm = 0.5*(ta+tb); float fm = F_crust(ro + tm*rd, g.Rsea); if (fm==0.0) break; bool same = (fm*fa)>0.0; ta = same? tm:ta; fa = same? fm:fa; tb = same? tb:tm; }
              }
              vec3 hitP = ro + tm * rd; vec3 n = gradF(hitP); color = 0.5*(n+vec3(1.0)); shaded = true; break;
            }
            // step to next voxel
            if (tMaxV.x <= tMaxV.y && tMaxV.x <= tMaxV.z) { tCellEnter = tMaxV.x; v.x += (r.x>0.0)?1:-1; tMaxV.x += tDeltaV.x; }
            else if (tMaxV.y <= tMaxV.z) { tCellEnter = tMaxV.y; v.y += (r.y>0.0)?1:-1; tMaxV.y += tDeltaV.y; }
            else { tCellEnter = tMaxV.z; v.z += (r.z>0.0)?1:-1; tMaxV.z += tDeltaV.z; }
            if (any(lessThan(v, ivec3(0))) || any(greaterThan(v, ivec3(VOXEL_BRICK_SIZE-1)))) break;
          }
          if (shaded) break;
        }
      }
    }
    // advance to next brick boundary
    // Advance along smallest tMax axis
    if (tMax.x <= tMax.y && tMax.x <= tMax.z) {
      tmin = tMax.x;
      bc.x += (rd.x > 0.0) ? 1 : -1;
      tMax.x += tDelta.x;
    } else if (tMax.y <= tMax.z) {
      tmin = tMax.y;
      bc.y += (rd.y > 0.0) ? 1 : -1;
      tMax.y += tDelta.y;
    } else {
      tmin = tMax.z;
      bc.z += (rd.z > 0.0) ? 1 : -1;
      tMax.z += tDelta.z;
    }
  }

  if (!shaded) {
    vec2 uv = (vec2(pix) + vec2(0.5)) / vec2(dims);
    float v = 1.0 - uv.y;
    color = mix(colorSkyBot, colorSkyTop, pow(v, 1.5));
  }
  imageStore(accumImage, pix, vec4(color, 1.0));
}
