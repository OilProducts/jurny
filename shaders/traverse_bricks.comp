#version 460

#extension GL_ARB_gpu_shader_int64 : enable

#include "common.glsl"
#include "spherical.glsl"
#include "include/brick_formats.glsl"

// =================================================================================================
// traverse_bricks.comp â€” primary/secondary ray traversal over sparse bricks with spherical clamp.
// Produces hit/miss payloads for the shading stage using wavefront queues.
// =================================================================================================

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Globals -----------------------------------------------------------------------------
// Retained for compatibility (debug skim); traversal does not write directly to the accum image.
layout(set = 0, binding = 1, rgba16f) uniform writeonly image2D accumImage;

layout(set = 0, binding = 3, std430) readonly buffer BrickHeadersBuf { BrickHeader headers[]; } BH;
layout(set = 0, binding = 4, std430) readonly buffer OccupancyBuf   { uint64_t occWords[];    } OCC;
layout(set = 0, binding = 5, std430) readonly buffer WorldHashKeys  { uint64_t worldKeys[];   };
layout(set = 0, binding = 6, std430) readonly buffer WorldHashVals  { uint      worldVals[];  };
layout(set = 0, binding = 7, std430) readonly buffer MacroHashKeys  { uint64_t macroKeys[];   };
layout(set = 0, binding = 8, std430) readonly buffer MacroHashVals  { uint      macroVals[];  };

// Debug buffer is optional; untouched unless enabled on the CPU.
layout(set = 0, binding = 9, std430) buffer DebugOut { uint dbg[]; } DBG;

// Queue plumbing ----------------------------------------------------------------------
struct QueueHeader {
  uint head;      // dequeue index
  uint tail;      // enqueue index
  uint capacity;  // power-of-two ring capacity
  uint dropped;   // overflow counter
};

struct RayPayload {
  vec3  origin;
  float tMin;
  vec3  direction;
  float tMax;
  vec3  throughput;
  float padThroughput;
  uint  rng;
  uint  pixelIndex;
  uint  pathDepth;
  uint  flags;
};

struct HitPayload {
  vec3  position;
  float t;
  vec3  normal;
  uint  material;
  vec3  direction;
  uint  rng;
  uint  pixelIndex;
  uint  pathDepth;
  vec3  throughput;
  float padThroughput;
};

struct MissPayload {
  vec3  origin;
  float tMin;
  vec3  direction;
  float tMax;
  vec3  throughput;
  float padThroughput;
  uint  rng;
  uint  pixelIndex;
  uint  pathDepth;
  uint  reason;
};

layout(set = 0, binding = 10, std430) buffer RayQueueInBuf {
  QueueHeader header;
  RayPayload  rays[];
} RayQueueIn;

layout(set = 0, binding = 11, std430) buffer HitQueueBuf {
  QueueHeader header;
  HitPayload  hits[];
} HitQueue;

layout(set = 0, binding = 12, std430) buffer MissQueueBuf {
  QueueHeader header;
  MissPayload misses[];
} MissQueue;

layout(set = 0, binding = 13, std430) buffer SecondaryQueueBuf {
  QueueHeader header;
  RayPayload  rays[];
} SecondaryQueue;

layout(set = 0, binding = 14, std430) buffer TraverseStatsBuf {
  uint macroVisited;
  uint macroSkipped;
  uint brickSteps;
  uint sphereSteps;
  uint hitsTotal;
  uint sphereMisses;
  uint pad1;
  uint pad2;
} TraverseStats;

layout(set = 0, binding = 23, std430) readonly buffer MaterialIndicesBuf {
  uint materialIndices[];
};

layout(set = 0, binding = 25, std430) readonly buffer PaletteBuf {
  uint paletteEntries[];
};

// Constants ----------------------------------------------------------------------------
const float INF_T              = 1e30;
const float BRICK_NUDGE        = 1e-5;
const float MACRO_STEP_EPS     = 1e-5;
const float REFINE_EPS         = 0.5;      // gradient epsilon (in voxel units)
const int   BRICK_MAX_STEPS    = 4096;
const int   MACRO_MAX_STEPS    = 2048;
const int   SPHERE_TRACE_MAX_STEPS = 128;   // max iterations per brick segment
const int   REFINE_MAX_ITERS   = 6;
const float SPHERE_TRACE_SAFETY          = 0.9; // scales signed distance before advancing to reduce overshoot
const float SPHERE_TRACE_EPS_VOX         = 0.5; // convergence threshold proportional to voxel size
const float SPHERE_TRACE_MIN_STEP_VOX    = 0.1; // lower clamp in voxels so we keep moving near flat surfaces
const float SPHERE_TRACE_MAX_STEP_BRICK  = 2.0; // upper clamp in bricks to avoid leaping past thin features
const uint  FLAG_ENABLE_MACRO        = 8u;       // matches CPU/debug flag bit
const uint  FLAG_FORCE_BLOCK_NORMALS = 32u;
const uint  MISS_REASON_ENV    = 0u;
const uint  MISS_REASON_SHELL  = 1u;
const uint  MISS_REASON_BAND   = 2u;
const uint  MISS_SLOT_INVALID  = 0xFFFFFFFFu;

// Shared state for chunked queue fetch.
// -------------------------------------------------------------------------------------------------
// Utility helpers
// -------------------------------------------------------------------------------------------------

int floorDiv(int a, int b) {
  int q = a / b;
  int r = a - q * b;
  if (((a ^ b) < 0) && (r != 0)) q -= 1;
  return q;
}

float safeReciprocal(float v) {
  return (abs(v) > 1e-20) ? 1.0 / v : 0.0;
}

float safeNextBoundary(float pos, float mn, float mx, float dir) {
  if (dir > 0.0) return (mx - pos) / dir;
  if (dir < 0.0) return (pos - mn) / -dir;
  return INF_T;
}

uint64_t packKey(ivec3 c) {
  const int B = 1 << 20;
  return ((uint64_t(c.x + B) << 42) |
          (uint64_t(c.y + B) << 21) |
           uint64_t(c.z + B));
}

bool findBrick(ivec3 bc, out uint brickIdx) {
  uint cap = g.worldHashCapacity;
  if (cap == 0u) return false;
  uint64_t key = packKey(bc);
  uint mask = cap - 1u;
  uint64_t kx = key ^ (key >> 33u);
  const uint64_t A = (uint64_t(0xff51afd7u) << 32) | uint64_t(0xed558ccdu);
  uint h = uint((kx * A) >> 32) & mask;
  for (uint probe = 0u; probe < cap; ++probe) {
    uint idx = (h + probe) & mask;
    uint64_t stored = worldKeys[idx];
    if (stored == key) {
      brickIdx = worldVals[idx];
      return true;
    }
    if (stored == 0ul) break;
  }
  return false;
}

bool macroTileOccupied(ivec3 mc) {
  uint cap = g.macroHashCapacity;
  if (cap == 0u) return false;
  uint64_t key = packKey(mc);
  uint mask = cap - 1u;
  uint64_t kx = key ^ (key >> 33u);
  const uint64_t A = (uint64_t(0xff51afd7u) << 32) | uint64_t(0xed558ccdu);
  uint h = uint((kx * A) >> 32) & mask;
  for (uint probe = 0u; probe < cap; ++probe) {
    uint idx = (h + probe) & mask;
    uint64_t stored = macroKeys[idx];
    if (stored == key) return macroVals[idx] != 0u;
    if (stored == 0ul) break;
  }
  return false;
}

bool brickHasOccupancy(const BrickHeader h) {
  uint base = h.occOffset >> 3u; // bytes -> uint64 index
  for (int i = 0; i < 8; ++i) {
    if (OCC.occWords[base + uint(i)] != 0ul) return true;
  }
  return false;
}

float evaluateFieldAnalytic(vec3 worldPos) {
  return F_crust(worldPos);
}

vec3 evaluateNormalAnalytic(vec3 worldPos) {
  return gradF(worldPos);
}

vec3 blockNormalForDir(vec3 dir) {
  vec3 absDir = abs(dir);
  if (absDir.x >= absDir.y && absDir.x >= absDir.z) {
    return vec3(dir.x > 0.0 ? -1.0 : 1.0, 0.0, 0.0);
  }
  if (absDir.y >= absDir.x && absDir.y >= absDir.z) {
    return vec3(0.0, dir.y > 0.0 ? -1.0 : 1.0, 0.0);
  }
  return vec3(0.0, 0.0, dir.z > 0.0 ? -1.0 : 1.0);
}

bool refineSurface(vec3 origin,
                   vec3 dir,
                   float ta,
                   float tb,
                   out float tOut) {
  vec3 originWorld = origin + g.renderOrigin;
  float fa = evaluateFieldAnalytic(originWorld + dir * ta);
  float fb = evaluateFieldAnalytic(originWorld + dir * tb);
  tOut = ta;
  if (fa * fb > 0.0) {
    return false; // no sign change along this segment
  }
  float a = ta;
  float b = tb;
  float tMid = ta;
  for (int i = 0; i < REFINE_MAX_ITERS; ++i) {
    tMid = 0.5 * (a + b);
    float fm = evaluateFieldAnalytic(originWorld + dir * tMid);
    if (fm == 0.0) break;
    bool same = (fm * fa) > 0.0;
    if (same) {
      a = tMid;
      fa = fm;
    } else {
      b = tMid;
      fb = fm;
    }
  }
  tOut = tMid;
  return true;
}

uint fallbackMaterialId() {
  return 0u;
}

bool fetchMaterialId(uint linearIndex, BrickHeader h, out uint materialId) {
  uint flags = brickFlags(h);
  uint baseWord = h.matIdxOffset >> 2u;
  if ((flags & BRICK_FLAG_USES4BIT) != 0u) {
    uint wordIndex = baseWord + (linearIndex >> 3u);
    if (wordIndex >= materialIndices.length()) {
      return false;
    }
    uint word = materialIndices[wordIndex];
    uint shift = (linearIndex & 7u) << 2u;
    uint paletteIdx = (word >> shift) & 0xFu;
    uint paletteCount = brickPaletteCount(h);
    if (paletteCount == 0u) {
      materialId = paletteIdx;
      return true;
    }
    if (paletteIdx >= paletteCount || h.paletteOffset == BRICK_INVALID_OFFSET) {
      return false;
    }
    uint paletteBase = h.paletteOffset >> 2u;
    uint paletteIndex = paletteBase + paletteIdx;
    if (paletteIndex >= paletteEntries.length()) {
      return false;
    }
    materialId = paletteEntries[paletteIndex];
    return true;
  } else {
    uint wordIndex = baseWord + (linearIndex >> 2u);
    if (wordIndex >= materialIndices.length()) {
      return false;
    }
    uint word = materialIndices[wordIndex];
    uint shift = (linearIndex & 3u) << 3u;
    materialId = (word >> shift) & 0xFFu;
    return true;
  }
}

bool fetchMaterialAtWorld(vec3 hitWorld, const BrickHeader h, out uint materialId) {
  vec3 brickOriginWorld = vec3(h.bx, h.by, h.bz) * g.brickSize;
  vec3 local = (hitWorld - brickOriginWorld) / g.voxelSize;
  ivec3 voxel = clamp(ivec3(floor(local)), ivec3(0), ivec3(VOXEL_BRICK_SIZE - 1));
  uint linear = uint(voxel.x) +
                uint(voxel.y) * uint(VOXEL_BRICK_SIZE) +
                uint(voxel.z) * uint(VOXEL_BRICK_SIZE * VOXEL_BRICK_SIZE);
  return fetchMaterialId(linear, h, materialId);
}

// -------------------------------------------------------------------------------------------------
// Queue helpers
// -------------------------------------------------------------------------------------------------

bool dequeuePrimaryRay(out RayPayload ray) {
  for (;;) {
    uint idx = atomicAdd(RayQueueIn.header.head, 1u);
    uint tail = RayQueueIn.header.tail;
    if (idx < tail) {
      uint slot = idx & (RayQueueIn.header.capacity - 1u);
      ray = RayQueueIn.rays[slot];
      return true;
    }
    atomicAdd(RayQueueIn.header.head, uint(0u - 1u));
    if (idx >= tail) return false;
  }
}

bool dequeueSecondaryRay(out RayPayload ray) {
  for (;;) {
    uint idx = atomicAdd(SecondaryQueue.header.head, 1u);
    uint tail = SecondaryQueue.header.tail;
    if (idx < tail) {
      uint slot = idx & (SecondaryQueue.header.capacity - 1u);
      ray = SecondaryQueue.rays[slot];
      return true;
    }
    atomicAdd(SecondaryQueue.header.head, uint(0u - 1u));
    if (idx >= tail) return false;
  }
}

bool dequeueRay(out RayPayload ray) {
  return (dispatch.queueSrc == 0u) ? dequeuePrimaryRay(ray)
                                   : dequeueSecondaryRay(ray);
}

uint reserveMissSlot(uint overflowReason) {
  uint slot = atomicAdd(MissQueue.header.tail, 1u);
  uint capacity = MissQueue.header.capacity;
  if (capacity == 0u) {
    atomicAdd(MissQueue.header.dropped, 1u);
    return MISS_SLOT_INVALID;
  }
  uint headSnapshot = MissQueue.header.head;
  if ((slot - headSnapshot) >= capacity) {
    atomicAdd(MissQueue.header.dropped, max(1u, overflowReason));
    return headSnapshot & (capacity - 1u);
  }
  return slot & (capacity - 1u);
}

void enqueueMiss(const RayPayload ray, uint reason) {
  uint slot = reserveMissSlot(reason + 1u);
  if (slot == MISS_SLOT_INVALID) return;
  MissPayload payload;
  payload.origin     = ray.origin;
  payload.tMin       = ray.tMin;
  payload.direction  = ray.direction;
  payload.tMax       = ray.tMax;
  payload.throughput = ray.throughput;
  payload.padThroughput = 0.0;
  payload.rng        = ray.rng;
  payload.pixelIndex = ray.pixelIndex;
  payload.pathDepth  = ray.pathDepth;
  payload.reason     = reason;
  MissQueue.misses[slot] = payload;
}

void enqueueHit(const RayPayload ray, float tHit, vec3 normal, uint material) {
  uint slot = atomicAdd(HitQueue.header.tail, 1u);
  uint capacity = HitQueue.header.capacity;
  if (capacity == 0u) {
    atomicAdd(HitQueue.header.dropped, 1u);
    return;
  }
  uint headSnapshot = HitQueue.header.head;
  if ((slot - headSnapshot) >= capacity) {
    atomicAdd(HitQueue.header.dropped, 1u);
    slot = headSnapshot;
  }
  slot &= (capacity - 1u);
  HitPayload payload;
  payload.position   = ray.origin + ray.direction * tHit;
  payload.t          = tHit;
  payload.normal     = normal;
  payload.material   = material;
  payload.direction  = ray.direction;
  payload.rng        = ray.rng;
  payload.pixelIndex = ray.pixelIndex;
  payload.pathDepth  = ray.pathDepth;
  payload.throughput = ray.throughput;
  payload.padThroughput = 0.0;
  HitQueue.hits[slot] = payload;
}

// -------------------------------------------------------------------------------------------------
// Debug helpers (single invocation writes per-dispatch diagnostics)
// -------------------------------------------------------------------------------------------------

void recordMacroDiag(ivec3 startCoords,
                     uint startPresent,
                     uint stepCount,
                     ivec3 endCoords,
                     uint endPresent,
                     uint reasonCode) {
  if ((g.flags & FLAG_ENABLE_MACRO) == 0u) return;
  if (gl_GlobalInvocationID.x != 0u || gl_GlobalInvocationID.y != 0u || gl_GlobalInvocationID.z != 0u) return;
  const uint base = 60u;
  if (atomicCompSwap(DBG.dbg[base], 0u, 1u) != 0u) return;
  DBG.dbg[base + 1u]  = uint(startCoords.x);
  DBG.dbg[base + 2u]  = uint(startCoords.y);
  DBG.dbg[base + 3u]  = uint(startCoords.z);
  DBG.dbg[base + 4u]  = startPresent;
  DBG.dbg[base + 5u]  = stepCount;
  DBG.dbg[base + 6u]  = uint(endCoords.x);
  DBG.dbg[base + 7u]  = uint(endCoords.y);
  DBG.dbg[base + 8u]  = uint(endCoords.z);
  DBG.dbg[base + 9u]  = endPresent;
  DBG.dbg[base + 10u] = reasonCode;
}

// -------------------------------------------------------------------------------------------------
// Macro skipping
// -------------------------------------------------------------------------------------------------

bool sphereTraceBrick(const RayPayload ray,
                      float tEnter,
                      float tExit,
                      const BrickHeader h,
                      out float tHit,
                      out vec3 hitNormal,
                      out uint materialId) {
  float t0 = max(tEnter, ray.tMin);
  float t1 = min(tExit, ray.tMax);
  if (t0 > t1) return false;

  vec3 originWorld = ray.origin + g.renderOrigin;
  vec3 dir = ray.direction;
  if (length(dir) == 0.0) return false;

  float epsilon = g.voxelSize * SPHERE_TRACE_EPS_VOX;
  float minStep = g.voxelSize * SPHERE_TRACE_MIN_STEP_VOX;
  float maxStep = g.brickSize * SPHERE_TRACE_MAX_STEP_BRICK;
  bool forceBlockNormal = ((g.flags & FLAG_FORCE_BLOCK_NORMALS) != 0u);

  float tCurrent = t0;
  float prevT = t0;
  float prevDist = evaluateFieldAnalytic(originWorld + dir * tCurrent);
  float dist = prevDist;

  for (int iter = 0; iter < SPHERE_TRACE_MAX_STEPS && tCurrent <= t1; ++iter) {
    atomicAdd(TraverseStats.sphereSteps, 1u);
    if (dist <= epsilon) {
      vec3 hitWorld = originWorld + dir * tCurrent;
      if (forceBlockNormal) {
        hitNormal = blockNormalForDir(dir);
      } else {
        vec3 grad = evaluateNormalAnalytic(hitWorld);
        hitNormal = (length(grad) > 0.0) ? normalize(grad) : normalize(dir);
      }
      tHit = tCurrent;
      if (!fetchMaterialAtWorld(hitWorld, h, materialId)) {
        materialId = fallbackMaterialId();
      }
      return true;
    }

    float stepLen = dist * SPHERE_TRACE_SAFETY;
    stepLen = clamp(stepLen, minStep, maxStep);
    if (!(stepLen > 0.0) || isnan(stepLen) || isinf(stepLen)) {
      break;
    }

    prevT = tCurrent;
    prevDist = dist;
    float nextT = tCurrent + stepLen;
    bool clamped = nextT >= t1;
    tCurrent = clamped ? t1 : nextT;
    dist = evaluateFieldAnalytic(originWorld + dir * tCurrent);
    if (clamped) {
      if (dist <= epsilon) {
        continue;
      }
      break;
    }
  }

  float tFallback;
  bool refined = (prevDist * dist) < 0.0 && refineSurface(ray.origin,
                                                         dir,
                                                         min(prevT, t1),
                                                         min(tCurrent, t1),
                                                         tFallback);
  if (refined) {
    vec3 hitWorld = originWorld + dir * tFallback;
    if (forceBlockNormal) {
      hitNormal = blockNormalForDir(dir);
    } else {
      vec3 grad = evaluateNormalAnalytic(hitWorld);
      hitNormal = (length(grad) > 0.0) ? normalize(grad) : normalize(dir);
    }
    tHit = tFallback;
    if (!fetchMaterialAtWorld(hitWorld, h, materialId)) {
      materialId = fallbackMaterialId();
    }
    return true;
  }

  atomicAdd(TraverseStats.sphereMisses, 1u);
  return false;
}

// -------------------------------------------------------------------------------------------------
// Main traversal
// -------------------------------------------------------------------------------------------------

void processRay(const RayPayload rayIn) {
  RayPayload ray = rayIn;
  vec3 renderOrigin = g.renderOrigin;
  vec3 rayOriginWorld = ray.origin + renderOrigin;

  float shellEnter, shellExit;
  if (!intersectSphereShell(rayOriginWorld, ray.direction, g.Rin, g.Rout, shellEnter, shellExit)) {
    enqueueMiss(ray, MISS_REASON_SHELL);
    return;
  }

  float tMin = max(ray.tMin, shellEnter);
  float tMax = min(ray.tMax, shellExit);
  if (tMin >= tMax) {
    enqueueMiss(ray, MISS_REASON_SHELL);
    return;
  }

  // Near-surface band to prioritise traversal around the crust
  float tBandMin = tMin;
  float tBandMax = tMax;
  float sea0, sea1;
  if (intersectSphere(rayOriginWorld, ray.direction, g.Rsea, sea0, sea1)) {
    float sea = INF_T;
    if (sea0 >= tMin && sea0 <= tMax) sea = min(sea, sea0);
    if (sea1 >= tMin && sea1 <= tMax) sea = min(sea, sea1);
    if (sea < INF_T * 0.5) {
      float baseBand = 8.0 * g.brickSize;
      float bandBelow = max(baseBand, -g.noiseMinHeight + g.brickSize);
      float bandAbove = max(baseBand, g.noiseMaxHeight + g.brickSize);
      float eps  = 1e-4 * g.brickSize;
      tBandMin = max(shellEnter, sea - bandBelow) + eps;
      tBandMax = min(shellExit, sea + bandAbove);
    }
  }

  float tMacroMin = max(tMin, tBandMin);
  float tMacroMax = min(tMax, tBandMax);

  float tCursor = tMacroMin;
  if (tCursor >= tMax) {
    enqueueMiss(ray, MISS_REASON_ENV);
    return;
  }
  vec3 dir = ray.direction;
  vec3 posStartWorld = rayOriginWorld + dir * (tCursor + BRICK_NUDGE * g.brickSize);
  ivec3 brickCoords = ivec3(floor(posStartWorld / g.brickSize));

  float macroSize = g.macroSize;
  int macroDim = int(g.macroDimBricks);
  bool useMacroSkip = ((g.flags & FLAG_ENABLE_MACRO) != 0u) && (g.macroHashCapacity > 0u) && (macroDim > 0) && (macroSize > 0.0);
  ivec3 macroCoords = ivec3(0);
  if (useMacroSkip) {
    macroCoords = ivec3(
      floorDiv(brickCoords.x, macroDim),
      floorDiv(brickCoords.y, macroDim),
      floorDiv(brickCoords.z, macroDim)
    );
  }

  vec3 invDir = vec3(
    safeReciprocal(dir.x),
    safeReciprocal(dir.y),
    safeReciprocal(dir.z)
  );
  vec3 absInvDir = abs(invDir);
  vec3 tDelta = vec3(g.brickSize) * absInvDir;

  for (int step = 0; step < BRICK_MAX_STEPS && tCursor < tMax; ++step) {
    vec3 cellMinWorld = vec3(brickCoords) * g.brickSize;
    vec3 cellMaxWorld = cellMinWorld + vec3(g.brickSize);
    vec3 samplePosWorld = rayOriginWorld + dir * (tCursor + BRICK_NUDGE * g.brickSize);

    float tx = tCursor + safeNextBoundary(samplePosWorld.x, cellMinWorld.x, cellMaxWorld.x, dir.x);
    float ty = tCursor + safeNextBoundary(samplePosWorld.y, cellMinWorld.y, cellMaxWorld.y, dir.y);
    float tz = tCursor + safeNextBoundary(samplePosWorld.z, cellMinWorld.z, cellMaxWorld.z, dir.z);
    float tBrickExit = min(tx, min(ty, tz));

    // Macro skip inside the loop to avoid spending time in empty coarse tiles.
    if (useMacroSkip) {
      bool skipped = false;
      int macroLoop = 0;
      ivec3 diagStart = macroCoords;
      uint diagStartPresent = macroTileOccupied(macroCoords) ? 1u : 0u;
      ivec3 diagEnd = diagStart;
      uint diagEndPresent = diagStartPresent;
      uint diagSteps = 0u;
      uint diagReason = (diagStartPresent != 0u) ? 0u : 5u;

      if (diagStartPresent == 0u) {
        for (;;) {
          atomicAdd(TraverseStats.macroSkipped, 1u);
          skipped = true;
          diagSteps += 1u;
          if (macroLoop++ >= MACRO_MAX_STEPS) {
            useMacroSkip = false;
            diagReason = 1u; // exceeded guard steps
            break;
          }

          vec3 macroMin = vec3(macroCoords) * macroSize;
          vec3 macroMax = macroMin + vec3(macroSize);
          vec3 macroSample = rayOriginWorld + dir * tCursor;
          float txMacro = (abs(dir.x) < 1e-20) ? INF_T : safeNextBoundary(macroSample.x, macroMin.x, macroMax.x, dir.x);
          float tyMacro = (abs(dir.y) < 1e-20) ? INF_T : safeNextBoundary(macroSample.y, macroMin.y, macroMax.y, dir.y);
          float tzMacro = (abs(dir.z) < 1e-20) ? INF_T : safeNextBoundary(macroSample.z, macroMin.z, macroMax.z, dir.z);
          float tAdvance = min(txMacro, min(tyMacro, tzMacro));
          if (tAdvance < -1e-5) {
            useMacroSkip = false;
            diagReason = 4u; // invalid advance
            break;
          }

          tAdvance = max(tAdvance, 0.0);

          float nextCursor = tCursor + tAdvance + MACRO_STEP_EPS * macroSize;
          if (nextCursor >= tMacroMax) {
            diagReason = 2u; // exited band window
            diagEnd = macroCoords;
            diagEndPresent = 0u;
            recordMacroDiag(diagStart, diagStartPresent, diagSteps, diagEnd, diagEndPresent, diagReason);
            enqueueMiss(ray, MISS_REASON_BAND);
            return;
          }

          tCursor = min(nextCursor, tMax);
          if (tCursor >= tMax) {
            diagReason = 3u; // escaped traversal bounds
            diagEnd = macroCoords;
            diagEndPresent = 0u;
            recordMacroDiag(diagStart, diagStartPresent, diagSteps, diagEnd, diagEndPresent, diagReason);
            enqueueMiss(ray, MISS_REASON_ENV);
            return;
          }

          vec3 macroSamplePos = rayOriginWorld + dir * (tCursor + BRICK_NUDGE * g.brickSize);
          brickCoords = ivec3(floor(macroSamplePos / g.brickSize));
          macroCoords = ivec3(
            floorDiv(brickCoords.x, macroDim),
            floorDiv(brickCoords.y, macroDim),
            floorDiv(brickCoords.z, macroDim)
          );
          diagEnd = macroCoords;
          bool presentNext = macroTileOccupied(macroCoords);
          diagEndPresent = presentNext ? 1u : 0u;
          if (presentNext) {
            diagReason = 0u; // landed on occupied macro tile
            break;
          }

          if (tCursor >= tMacroMax) {
            diagReason = 2u;
            diagEndPresent = 0u;
            recordMacroDiag(diagStart, diagStartPresent, diagSteps, diagEnd, diagEndPresent, diagReason);
            enqueueMiss(ray, MISS_REASON_BAND);
            return;
          }
        }
      }

      recordMacroDiag(diagStart, diagStartPresent, diagSteps, diagEnd, diagEndPresent, diagReason);
      if (useMacroSkip && skipped && diagEndPresent == 1u) {
        atomicAdd(TraverseStats.macroVisited, 1u);
        continue;
      }
    }

    uint brickIdx;
    if (findBrick(brickCoords, brickIdx)) {
      BrickHeader h = BH.headers[brickIdx];
      if (brickHasOccupancy(h)) {
        float tHit;
        vec3 normal;
        uint material;
        if (sphereTraceBrick(ray, tCursor, min(tBrickExit, tMax), h, tHit, normal, material)) {
          atomicAdd(TraverseStats.hitsTotal, 1u);
          enqueueHit(ray, tHit, normal, material);
          return;
        }
      }
    }

    // Advance to next brick along the smallest tMax axis.
    if (tx <= ty && tx <= tz) {
      tCursor = tx;
      brickCoords.x += (dir.x >= 0.0) ? 1 : -1;
    } else if (ty <= tz) {
      tCursor = ty;
      brickCoords.y += (dir.y >= 0.0) ? 1 : -1;
    } else {
      tCursor = tz;
      brickCoords.z += (dir.z >= 0.0) ? 1 : -1;
    }
    atomicAdd(TraverseStats.brickSteps, 1u);
  }

  // Reached the end of the traversal window without hitting a voxel.
  enqueueMiss(ray, MISS_REASON_ENV);
}

void main() {
  for (;;) {
    RayPayload ray;
    if (!dequeueRay(ray)) {
      return;
    }
    processRay(ray);
  }
}
