#version 460

#extension GL_ARB_gpu_shader_int64 : enable

#include "common.glsl"
#include "spherical.glsl"
#include "include/brick_formats.glsl"

// =================================================================================================
// traverse_bricks.comp â€” primary/secondary ray traversal over sparse bricks with spherical clamp.
// Produces hit/miss payloads for the shading stage using wavefront queues.
// =================================================================================================

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Globals -----------------------------------------------------------------------------
layout(set = 0, binding = 0) uniform GlobalsUBO { GlobalsUBO_t g; };

// Retained for compatibility (debug skim); traversal does not write directly to the accum image.
layout(set = 0, binding = 1, rgba8) uniform writeonly image2D accumImage;

layout(set = 0, binding = 3, std430) readonly buffer BrickHeadersBuf { BrickHeader headers[]; } BH;
layout(set = 0, binding = 4, std430) readonly buffer OccupancyBuf   { uint64_t occWords[];    } OCC;
layout(set = 0, binding = 5, std430) readonly buffer WorldHashKeys  { uint64_t worldKeys[];   };
layout(set = 0, binding = 6, std430) readonly buffer WorldHashVals  { uint      worldVals[];  };
layout(set = 0, binding = 7, std430) readonly buffer MacroHashKeys  { uint64_t macroKeys[];   };
layout(set = 0, binding = 8, std430) readonly buffer MacroHashVals  { uint      macroVals[];  };

// Debug buffer is optional; untouched unless enabled on the CPU.
layout(set = 0, binding = 9, std430) buffer DebugOut { uint dbg[]; } DBG;

// Queue plumbing ----------------------------------------------------------------------
struct QueueHeader {
  uint head;      // dequeue index
  uint tail;      // enqueue index
  uint capacity;  // power-of-two ring capacity
  uint dropped;   // overflow counter
};

struct RayPayload {
  vec3  origin;
  float tMin;
  vec3  direction;
  float tMax;
  uint  rng;
  uint  pixelIndex;
  uint  pathDepth;
  uint  flags;
};

struct HitPayload {
  vec3  position;
  float t;
  vec3  normal;
  uint  material;
  vec3  direction;
  uint  rng;
  uint  pixelIndex;
  uint  pathDepth;
};

struct MissPayload {
  vec3  origin;
  float tMin;
  vec3  direction;
  float tMax;
  uint  rng;
  uint  pixelIndex;
  uint  pathDepth;
  uint  reason;
};

layout(set = 0, binding = 10, std430) buffer RayQueueInBuf {
  QueueHeader header;
  RayPayload  rays[];
} RayQueueIn;

layout(set = 0, binding = 11, std430) buffer HitQueueBuf {
  QueueHeader header;
  HitPayload  hits[];
} HitQueue;

layout(set = 0, binding = 12, std430) buffer MissQueueBuf {
  QueueHeader header;
  MissPayload misses[];
} MissQueue;

layout(set = 0, binding = 13, std430) buffer SecondaryQueueBuf {
  QueueHeader header;
  RayPayload  rays[];
} SecondaryQueue;

// Constants ----------------------------------------------------------------------------
const float INF_T              = 1e30;
const float BRICK_NUDGE        = 1e-5;
const float MACRO_STEP_EPS     = 1e-5;
const float REFINE_EPS         = 0.5;      // gradient epsilon (in voxel units)
const int   BRICK_MAX_STEPS    = 4096;
const int   MACRO_MAX_STEPS    = 2048;
const int   MICRO_MAX_STEPS    = 128;
const int   REFINE_MAX_ITERS   = 6;
const uint  FLAG_ENABLE_MACRO  = 8u;       // matches CPU/debug flag bit
const uint  MISS_REASON_ENV    = 0u;
const uint  MISS_REASON_SHELL  = 1u;
const uint  MISS_REASON_BAND   = 2u;

// Shared state for chunked queue fetch.
// -------------------------------------------------------------------------------------------------
// Utility helpers
// -------------------------------------------------------------------------------------------------

int floorDiv(int a, int b) {
  int q = a / b;
  int r = a - q * b;
  if (((a ^ b) < 0) && (r != 0)) q -= 1;
  return q;
}

float safeReciprocal(float v) {
  return (abs(v) > 1e-20) ? 1.0 / v : 0.0;
}

float safeNextBoundary(float pos, float mn, float mx, float dir) {
  if (dir > 0.0) return (mx - pos) / dir;
  if (dir < 0.0) return (pos - mn) / -dir;
  return INF_T;
}

uint64_t packKey(ivec3 c) {
  const int B = 1 << 20;
  return ((uint64_t(c.x + B) << 42) |
          (uint64_t(c.y + B) << 21) |
           uint64_t(c.z + B));
}

bool findBrick(ivec3 bc, out uint brickIdx) {
  uint cap = g.worldHashCapacity;
  if (cap == 0u) return false;
  uint64_t key = packKey(bc);
  uint mask = cap - 1u;
  uint64_t kx = key ^ (key >> 33u);
  const uint64_t A = (uint64_t(0xff51afd7u) << 32) | uint64_t(0xed558ccdu);
  uint h = uint((kx * A) >> 32) & mask;
  for (uint probe = 0u; probe < cap; ++probe) {
    uint idx = (h + probe) & mask;
    uint64_t stored = worldKeys[idx];
    if (stored == key) {
      brickIdx = worldVals[idx];
      return true;
    }
    if (stored == 0ul) break;
  }
  return false;
}

bool macroTileOccupied(ivec3 mc) {
  uint cap = g.macroHashCapacity;
  if (cap == 0u) return false;
  uint64_t key = packKey(mc);
  uint mask = cap - 1u;
  uint64_t kx = key ^ (key >> 33u);
  const uint64_t A = (uint64_t(0xff51afd7u) << 32) | uint64_t(0xed558ccdu);
  uint h = uint((kx * A) >> 32) & mask;
  for (uint probe = 0u; probe < cap; ++probe) {
    uint idx = (h + probe) & mask;
    uint64_t stored = macroKeys[idx];
    if (stored == key) return macroVals[idx] != 0u;
    if (stored == 0ul) break;
  }
  return false;
}

bool brickHasOccupancy(const BrickHeader h) {
  uint base = h.occOffset >> 3u; // bytes -> uint64 index
  for (int i = 0; i < 8; ++i) {
    if (OCC.occWords[base + uint(i)] != 0ul) return true;
  }
  return false;
}

float evaluateField(vec3 p, const BrickHeader /*h*/) {
  // Placeholder: use analytic crust field. When TSDF is available, sample it here.
  return F_crust(p, g.Rsea);
}

vec3 evaluateNormal(vec3 p, const BrickHeader h, float voxelSize) {
  float eps = max(voxelSize * REFINE_EPS, 1e-4);
  float fx1 = evaluateField(p + vec3(eps, 0.0, 0.0), h);
  float fx0 = evaluateField(p - vec3(eps, 0.0, 0.0), h);
  float fy1 = evaluateField(p + vec3(0.0, eps, 0.0), h);
  float fy0 = evaluateField(p - vec3(0.0, eps, 0.0), h);
  float fz1 = evaluateField(p + vec3(0.0, 0.0, eps), h);
  float fz0 = evaluateField(p - vec3(0.0, 0.0, eps), h);
  vec3 n = vec3(fx1 - fx0, fy1 - fy0, fz1 - fz0);
  return (length(n) > 0.0) ? normalize(n) : vec3(0.0, 1.0, 0.0);
}

float refineSurface(vec3 origin, vec3 dir, float ta, float tb, const BrickHeader h) {
  float fa = evaluateField(origin + dir * ta, h);
  float fb = evaluateField(origin + dir * tb, h);
  if (fa * fb > 0.0) return ta; // no sign change, fallback to entering point
  float a = ta;
  float b = tb;
  float tMid = ta;
  for (int i = 0; i < REFINE_MAX_ITERS; ++i) {
    tMid = 0.5 * (a + b);
    float fm = evaluateField(origin + dir * tMid, h);
    if (fm == 0.0) break;
    bool same = (fm * fa) > 0.0;
    if (same) {
      a = tMid;
      fa = fm;
    } else {
      b = tMid;
      fb = fm;
    }
  }
  return tMid;
}

uint fallbackMaterialId() {
  return 0u;
}

// -------------------------------------------------------------------------------------------------
// Queue helpers
// -------------------------------------------------------------------------------------------------

bool dequeueRay(out RayPayload ray) {
  for (;;) {
    uint idx = atomicAdd(RayQueueIn.header.head, 1u);
    uint tail = RayQueueIn.header.tail;
    if (idx < tail) {
      uint slot = idx & (RayQueueIn.header.capacity - 1u);
      ray = RayQueueIn.rays[slot];
      return true;
    }
    atomicAdd(RayQueueIn.header.head, uint(0u - 1u));
    if (idx >= tail) return false;
  }
}

uint reserveMissSlot(uint overflowReason) {
  uint slot = atomicAdd(MissQueue.header.tail, 1u);
  uint capacity = MissQueue.header.capacity;
  if (capacity == 0u) {
    atomicAdd(MissQueue.header.dropped, 1u);
    return 0u;
  }
  uint headSnapshot = MissQueue.header.head;
  if ((slot - headSnapshot) >= capacity) {
    atomicAdd(MissQueue.header.dropped, max(1u, overflowReason));
    return headSnapshot & (capacity - 1u);
  }
  return slot & (capacity - 1u);
}

void enqueueMiss(const RayPayload ray, uint reason) {
  uint slot = reserveMissSlot(reason + 1u);
  MissPayload payload;
  payload.origin     = ray.origin;
  payload.tMin       = ray.tMin;
  payload.direction  = ray.direction;
  payload.tMax       = ray.tMax;
  payload.rng        = ray.rng;
  payload.pixelIndex = ray.pixelIndex;
  payload.pathDepth  = ray.pathDepth;
  payload.reason     = reason;
  MissQueue.misses[slot] = payload;
}

void enqueueHit(const RayPayload ray, float tHit, vec3 normal, uint material) {
  uint slot = atomicAdd(HitQueue.header.tail, 1u);
  uint capacity = HitQueue.header.capacity;
  if (capacity == 0u) {
    atomicAdd(HitQueue.header.dropped, 1u);
    return;
  }
  uint headSnapshot = HitQueue.header.head;
  if ((slot - headSnapshot) >= capacity) {
    atomicAdd(HitQueue.header.dropped, 1u);
    slot = headSnapshot;
  }
  slot &= (capacity - 1u);
  HitPayload payload;
  payload.position   = ray.origin + ray.direction * tHit;
  payload.t          = tHit;
  payload.normal     = normal;
  payload.material   = material;
  payload.direction  = ray.direction;
  payload.rng        = ray.rng;
  payload.pixelIndex = ray.pixelIndex;
  payload.pathDepth  = ray.pathDepth;
  HitQueue.hits[slot] = payload;
}

// -------------------------------------------------------------------------------------------------
// Macro skipping
// -------------------------------------------------------------------------------------------------

bool traverseBrickMicro(const RayPayload ray,
                        float tEnter,
                        float tExit,
                        const BrickHeader h,
                        out float tHit,
                        out vec3 hitNormal,
                        out uint materialId) {
  float t0 = max(tEnter, ray.tMin);
  float t1 = min(tExit, ray.tMax);
  if (t0 > t1) return false;

  vec3 brickOrigin = vec3(h.bx, h.by, h.bz) * g.brickSize;
  vec3 dir = ray.direction;
  if (length(dir) == 0.0) return false;

  vec3 p0 = ray.origin + dir * t0;
  vec3 local = (p0 - brickOrigin) / g.voxelSize;

  ivec3 voxel = clamp(ivec3(floor(local)), ivec3(0), ivec3(VOXEL_BRICK_SIZE - 1));
  ivec3 step = ivec3(
    (dir.x > 0.0) ? 1 : ((dir.x < 0.0) ? -1 : 0),
    (dir.y > 0.0) ? 1 : ((dir.y < 0.0) ? -1 : 0),
    (dir.z > 0.0) ? 1 : ((dir.z < 0.0) ? -1 : 0)
  );

  vec3 invDir = vec3(
    safeReciprocal(dir.x),
    safeReciprocal(dir.y),
    safeReciprocal(dir.z)
  );
  vec3 absInv = abs(invDir);
  vec3 tDelta = vec3(g.voxelSize) * absInv;

  vec3 nextBoundary;
  nextBoundary.x = (step.x > 0) ? ((float(voxel.x) + 1.0) - local.x) : (local.x - float(voxel.x));
  nextBoundary.y = (step.y > 0) ? ((float(voxel.y) + 1.0) - local.y) : (local.y - float(voxel.y));
  nextBoundary.z = (step.z > 0) ? ((float(voxel.z) + 1.0) - local.z) : (local.z - float(voxel.z));
  nextBoundary = max(nextBoundary, vec3(0.0));

  vec3 tMax = vec3(
    (step.x == 0) ? INF_T : (t0 + nextBoundary.x * absInv.x * g.voxelSize),
    (step.y == 0) ? INF_T : (t0 + nextBoundary.y * absInv.y * g.voxelSize),
    (step.z == 0) ? INF_T : (t0 + nextBoundary.z * absInv.z * g.voxelSize)
  );

  float tCellEnter = t0;
  uint baseWord = h.occOffset >> 3u;

  for (int iter = 0; iter < MICRO_MAX_STEPS && tCellEnter <= t1; ++iter) {
    uint linear = uint(voxel.x) +
                  uint(voxel.y) * uint(VOXEL_BRICK_SIZE) +
                  uint(voxel.z) * uint(VOXEL_BRICK_SIZE * VOXEL_BRICK_SIZE);
    uint word = baseWord + (linear >> 6u);
    uint bit  = linear & 63u;
    bool occupied = ((OCC.occWords[word] >> bit) & 1ul) != 0ul;

    float tCellExit = min(tMax.x, min(tMax.y, tMax.z));
    if (occupied) {
      float tRefined = refineSurface(ray.origin, dir, tCellEnter, min(tCellExit, t1), h);
      vec3 normal = evaluateNormal(ray.origin + dir * tRefined, h, g.voxelSize);
      tHit = tRefined;
      hitNormal = normal;
      materialId = fallbackMaterialId(); // TODO: decode palette/material streams
      return true;
    }

    if (tCellExit > t1) break;

    if (tMax.x <= tMax.y && tMax.x <= tMax.z) {
      tCellEnter = tMax.x;
      if (step.x == 0) break;
      tMax.x += tDelta.x;
      voxel.x += step.x;
    } else if (tMax.y <= tMax.z) {
      tCellEnter = tMax.y;
      if (step.y == 0) break;
      tMax.y += tDelta.y;
      voxel.y += step.y;
    } else {
      tCellEnter = tMax.z;
      if (step.z == 0) break;
      tMax.z += tDelta.z;
      voxel.z += step.z;
    }

    if (any(lessThan(voxel, ivec3(0))) || any(greaterThan(voxel, ivec3(VOXEL_BRICK_SIZE - 1)))) {
      break;
    }
  }

  return false;
}

// -------------------------------------------------------------------------------------------------
// Main traversal
// -------------------------------------------------------------------------------------------------

void processRay(const RayPayload rayIn) {
  RayPayload ray = rayIn;

  float shellEnter, shellExit;
  if (!intersectSphereShell(ray.origin, ray.direction, g.Rin, g.Rout, shellEnter, shellExit)) {
    enqueueMiss(ray, MISS_REASON_SHELL);
    return;
  }

  float tMin = max(ray.tMin, shellEnter);
  float tMax = min(ray.tMax, shellExit);
  if (tMin >= tMax) {
    enqueueMiss(ray, MISS_REASON_SHELL);
    return;
  }

  // Near-surface band to prioritise traversal around the crust
  float tBandMin = tMin;
  float tBandMax = tMax;
  float sea0, sea1;
  if (intersectSphere(ray.origin, ray.direction, g.Rsea, sea0, sea1)) {
    float sea = INF_T;
    if (sea0 >= tMin && sea0 <= tMax) sea = min(sea, sea0);
    if (sea1 >= tMin && sea1 <= tMax) sea = min(sea, sea1);
    if (sea < INF_T * 0.5) {
      float band = 8.0 * g.brickSize;
      float eps  = 1e-4 * g.brickSize;
      tBandMin = max(shellEnter, sea - band) + eps;
      tBandMax = min(shellExit, sea + band);
    }
  }

  float tMacroMin = max(tMin, tBandMin);
  float tMacroMax = min(tMax, tBandMax);

  float tCursor = tMin;
  vec3 dir = ray.direction;
  vec3 posStart = ray.origin + dir * (tCursor + BRICK_NUDGE * g.brickSize);
  ivec3 brickCoords = ivec3(floor(posStart / g.brickSize));

  float macroSize = g.macroSize;
  int macroDim = int(g.macroDimBricks);
  bool useMacroSkip = ((g.flags & FLAG_ENABLE_MACRO) != 0u) && (g.macroHashCapacity > 0u) && (macroDim > 0) && (macroSize > 0.0);
  ivec3 macroCoords = ivec3(0);
  if (useMacroSkip) {
    macroCoords = ivec3(
      floorDiv(brickCoords.x, macroDim),
      floorDiv(brickCoords.y, macroDim),
      floorDiv(brickCoords.z, macroDim)
    );
  }

  vec3 invDir = vec3(
    safeReciprocal(dir.x),
    safeReciprocal(dir.y),
    safeReciprocal(dir.z)
  );
  vec3 absInvDir = abs(invDir);
  vec3 tDelta = vec3(g.brickSize) * absInvDir;

  for (int step = 0; step < BRICK_MAX_STEPS && tCursor < tMax; ++step) {
    vec3 cellMin = vec3(brickCoords) * g.brickSize;
    vec3 cellMax = cellMin + vec3(g.brickSize);
    vec3 samplePos = ray.origin + dir * (tCursor + BRICK_NUDGE * g.brickSize);

    float tx = tCursor + safeNextBoundary(samplePos.x, cellMin.x, cellMax.x, dir.x);
    float ty = tCursor + safeNextBoundary(samplePos.y, cellMin.y, cellMax.y, dir.y);
    float tz = tCursor + safeNextBoundary(samplePos.z, cellMin.z, cellMax.z, dir.z);
    float tBrickExit = min(tx, min(ty, tz));

    // Macro skip inside the loop to avoid spending time in empty coarse tiles.
    if (useMacroSkip) {
      bool skipped = false;
      int macroLoop = 0;
      while (!macroTileOccupied(macroCoords)) {
        if (macroLoop++ >= MACRO_MAX_STEPS) {
          useMacroSkip = false;
          break;
        }
        vec3 macroMin = vec3(macroCoords) * macroSize;
        vec3 macroMax = macroMin + vec3(macroSize);
        vec3 macroSample = ray.origin + dir * (tCursor + MACRO_STEP_EPS * macroSize);
        float txMacro = (abs(dir.x) < 1e-20) ? INF_T : safeNextBoundary(macroSample.x, macroMin.x, macroMax.x, dir.x);
        float tyMacro = (abs(dir.y) < 1e-20) ? INF_T : safeNextBoundary(macroSample.y, macroMin.y, macroMax.y, dir.y);
        float tzMacro = (abs(dir.z) < 1e-20) ? INF_T : safeNextBoundary(macroSample.z, macroMin.z, macroMax.z, dir.z);
        float tAdvance = min(txMacro, min(tyMacro, tzMacro));
        if (!(tAdvance >= 0.0)) {
          useMacroSkip = false;
          break;
        }
        float nextCursor = tCursor + tAdvance + MACRO_STEP_EPS * macroSize;
        if (nextCursor >= tMacroMax) {
          enqueueMiss(ray, MISS_REASON_BAND);
          return;
        }
        tCursor = min(nextCursor, tMax);
        if (tCursor >= tMax) {
          enqueueMiss(ray, MISS_REASON_ENV);
          return;
        }
        vec3 samplePos = ray.origin + dir * (tCursor + BRICK_NUDGE * g.brickSize);
        brickCoords = ivec3(floor(samplePos / g.brickSize));
        macroCoords = ivec3(
          floorDiv(brickCoords.x, macroDim),
          floorDiv(brickCoords.y, macroDim),
          floorDiv(brickCoords.z, macroDim)
        );
        macroMin = vec3(macroCoords) * macroSize;
        macroMax = macroMin + vec3(macroSize);
        skipped = true;
        if (tCursor >= tMacroMax) {
          enqueueMiss(ray, MISS_REASON_BAND);
          return;
        }
      }
      if (useMacroSkip && skipped) {
        continue;
      }
    }

    uint brickIdx;
    if (findBrick(brickCoords, brickIdx)) {
      BrickHeader h = BH.headers[brickIdx];
      if (brickHasOccupancy(h)) {
        float tHit;
        vec3 normal;
        uint material;
        if (traverseBrickMicro(ray, tCursor, min(tBrickExit, tMax), h, tHit, normal, material)) {
          enqueueHit(ray, tHit, normal, material);
          return;
        }
      }
    }

    // Advance to next brick along the smallest tMax axis.
    if (tx <= ty && tx <= tz) {
      tCursor = tx;
      brickCoords.x += (dir.x >= 0.0) ? 1 : -1;
    } else if (ty <= tz) {
      tCursor = ty;
      brickCoords.y += (dir.y >= 0.0) ? 1 : -1;
    } else {
      tCursor = tz;
      brickCoords.z += (dir.z >= 0.0) ? 1 : -1;
    }
  }

  // Reached the end of the traversal window without hitting a voxel.
  enqueueMiss(ray, MISS_REASON_ENV);
}

void main() {
  for (;;) {
    RayPayload ray;
    if (!dequeueRay(ray)) {
      return;
    }
    processRay(ray);
  }
}
