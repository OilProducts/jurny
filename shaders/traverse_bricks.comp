#version 460

#extension GL_ARB_gpu_shader_int64 : enable

#include "common.glsl"
#include "spherical.glsl"
#include "include/brick_formats.glsl"

// =================================================================================================
// traverse_bricks.comp â€” primary/secondary ray traversal over sparse bricks with spherical clamp.
// Produces hit/miss payloads for the shading stage using wavefront queues.
// =================================================================================================

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Globals -----------------------------------------------------------------------------
// Retained for compatibility (debug skim); traversal does not write directly to the accum image.
layout(set = 0, binding = 1, rgba16f) uniform writeonly image2D accumImage;

layout(set = 0, binding = 3, std430) readonly buffer BrickHeadersBuf { BrickHeader headers[]; } BH;
layout(set = 0, binding = 4, std430) readonly buffer OccupancyBuf   { uint64_t occWords[];    } OCC;
layout(set = 0, binding = 5, std430) readonly buffer WorldHashKeys  { uint64_t worldKeys[];   };
layout(set = 0, binding = 6, std430) readonly buffer WorldHashVals  { uint      worldVals[];  };
layout(set = 0, binding = 7, std430) readonly buffer MacroHashKeys  { uint64_t macroKeys[];   };
layout(set = 0, binding = 8, std430) readonly buffer MacroHashVals  { uint      macroVals[];  };

// Debug buffer is optional; untouched unless enabled on the CPU.
layout(set = 0, binding = 9, std430) buffer DebugOut { uint dbg[]; } DBG;

// Queue plumbing ----------------------------------------------------------------------
struct QueueHeader {
  uint head;      // dequeue index
  uint tail;      // enqueue index
  uint capacity;  // power-of-two ring capacity
  uint dropped;   // overflow counter
};

struct RayPayload {
  vec3  origin;
  float tMin;
  vec3  direction;
  float tMax;
  vec3  throughput;
  float padThroughput;
  uint  rng;
  uint  pixelIndex;
  uint  pathDepth;
  uint  flags;
};

struct HitPayload {
  vec3  position;
  float t;
  vec3  normal;
  uint  material;
  vec3  direction;
  uint  rng;
  uint  pixelIndex;
  uint  pathDepth;
  vec3  throughput;
  float padThroughput;
};

struct MissPayload {
  vec3  origin;
  float tMin;
  vec3  direction;
  float tMax;
  vec3  throughput;
  float padThroughput;
  uint  rng;
  uint  pixelIndex;
  uint  pathDepth;
  uint  reason;
};

layout(set = 0, binding = 10, std430) buffer RayQueueInBuf {
  QueueHeader header;
  RayPayload  rays[];
} RayQueueIn;

layout(set = 0, binding = 11, std430) buffer HitQueueBuf {
  QueueHeader header;
  HitPayload  hits[];
} HitQueue;

layout(set = 0, binding = 12, std430) buffer MissQueueBuf {
  QueueHeader header;
  MissPayload misses[];
} MissQueue;

layout(set = 0, binding = 13, std430) buffer SecondaryQueueBuf {
  QueueHeader header;
  RayPayload  rays[];
} SecondaryQueue;

layout(set = 0, binding = 14, std430) buffer TraverseStatsBuf {
  uint macroVisited;
  uint macroSkipped;
  uint brickSteps;
  uint microSteps;
  uint hitsTotal;
  uint pad0;
  uint pad1;
  uint pad2;
} TraverseStats;

layout(set = 0, binding = 23, std430) readonly buffer MaterialIndicesBuf {
  uint materialIndices[];
};

layout(set = 0, binding = 25, std430) readonly buffer PaletteBuf {
  uint paletteEntries[];
};

layout(set = 0, binding = 26, std430) readonly buffer FieldSamplesBuf {
  float fieldSamples[];
};

const uint FIELD_APRON = 1u;
const uint FIELD_DIM   = uint(VOXEL_BRICK_SIZE) + 1u + 2u * FIELD_APRON;
const uint FIELD_PLANE = FIELD_DIM * FIELD_DIM;
const uint FIELD_COUNT_PER_BRICK = FIELD_DIM * FIELD_PLANE;

bool brickFieldBase(const BrickHeader h, out uint baseIndex) {
  if (h.tsdfOffset == BRICK_INVALID_OFFSET) return false;
  uint base = h.tsdfOffset >> 2u;
  uint count = fieldSamples.length();
  if (count == 0u) return false;
  if (base + FIELD_COUNT_PER_BRICK > count) return false;
  baseIndex = base;
  return true;
}

float fetchFieldSample(uint baseIndex, int x, int y, int z) {
  uint idx = baseIndex + uint(x) + uint(y) * FIELD_DIM + uint(z) * FIELD_PLANE;
  return fieldSamples[idx];
}

// Constants ----------------------------------------------------------------------------
const float INF_T              = 1e30;
const float BRICK_NUDGE        = 1e-5;
const float MACRO_STEP_EPS     = 1e-5;
const float REFINE_EPS         = 0.5;      // gradient epsilon (in voxel units)
const int   BRICK_MAX_STEPS    = 4096;
const int   MACRO_MAX_STEPS    = 2048;
const int   MICRO_MAX_STEPS    = 128;
const int   REFINE_MAX_ITERS   = 6;
const uint  FLAG_ENABLE_MACRO        = 8u;       // matches CPU/debug flag bit
const uint  FLAG_FORCE_BLOCK_NORMALS = 32u;
const uint  MISS_REASON_ENV    = 0u;
const uint  MISS_REASON_SHELL  = 1u;
const uint  MISS_REASON_BAND   = 2u;

// Shared state for chunked queue fetch.
// -------------------------------------------------------------------------------------------------
// Utility helpers
// -------------------------------------------------------------------------------------------------

int floorDiv(int a, int b) {
  int q = a / b;
  int r = a - q * b;
  if (((a ^ b) < 0) && (r != 0)) q -= 1;
  return q;
}

float safeReciprocal(float v) {
  return (abs(v) > 1e-20) ? 1.0 / v : 0.0;
}

float safeNextBoundary(float pos, float mn, float mx, float dir) {
  if (dir > 0.0) return (mx - pos) / dir;
  if (dir < 0.0) return (pos - mn) / -dir;
  return INF_T;
}

uint64_t packKey(ivec3 c) {
  const int B = 1 << 20;
  return ((uint64_t(c.x + B) << 42) |
          (uint64_t(c.y + B) << 21) |
           uint64_t(c.z + B));
}

bool findBrick(ivec3 bc, out uint brickIdx) {
  uint cap = g.worldHashCapacity;
  if (cap == 0u) return false;
  uint64_t key = packKey(bc);
  uint mask = cap - 1u;
  uint64_t kx = key ^ (key >> 33u);
  const uint64_t A = (uint64_t(0xff51afd7u) << 32) | uint64_t(0xed558ccdu);
  uint h = uint((kx * A) >> 32) & mask;
  for (uint probe = 0u; probe < cap; ++probe) {
    uint idx = (h + probe) & mask;
    uint64_t stored = worldKeys[idx];
    if (stored == key) {
      brickIdx = worldVals[idx];
      return true;
    }
    if (stored == 0ul) break;
  }
  return false;
}

bool macroTileOccupied(ivec3 mc) {
  uint cap = g.macroHashCapacity;
  if (cap == 0u) return false;
  uint64_t key = packKey(mc);
  uint mask = cap - 1u;
  uint64_t kx = key ^ (key >> 33u);
  const uint64_t A = (uint64_t(0xff51afd7u) << 32) | uint64_t(0xed558ccdu);
  uint h = uint((kx * A) >> 32) & mask;
  for (uint probe = 0u; probe < cap; ++probe) {
    uint idx = (h + probe) & mask;
    uint64_t stored = macroKeys[idx];
    if (stored == key) return macroVals[idx] != 0u;
    if (stored == 0ul) break;
  }
  return false;
}

bool brickHasOccupancy(const BrickHeader h) {
  uint base = h.occOffset >> 3u; // bytes -> uint64 index
  for (int i = 0; i < 8; ++i) {
    if (OCC.occWords[base + uint(i)] != 0ul) return true;
  }
  return false;
}

float sampleBrickField(uint baseIndex, vec3 worldPos, const BrickHeader h) {
  vec3 brickOriginWorld = vec3(h.bx, h.by, h.bz) * g.brickSize;
  vec3 local = (worldPos - brickOriginWorld) / g.voxelSize + vec3(float(FIELD_APRON));

  float fx = clamp(local.x, 0.0, float(FIELD_DIM - 1u));
  float fy = clamp(local.y, 0.0, float(FIELD_DIM - 1u));
  float fz = clamp(local.z, 0.0, float(FIELD_DIM - 1u));

  int ix0 = clamp(int(floor(fx)), 0, int(FIELD_DIM) - 1);
  int iy0 = clamp(int(floor(fy)), 0, int(FIELD_DIM) - 1);
  int iz0 = clamp(int(floor(fz)), 0, int(FIELD_DIM) - 1);
  int ix1 = min(ix0 + 1, int(FIELD_DIM) - 1);
  int iy1 = min(iy0 + 1, int(FIELD_DIM) - 1);
  int iz1 = min(iz0 + 1, int(FIELD_DIM) - 1);

  float tx = clamp(fx - float(ix0), 0.0, 1.0);
  float ty = clamp(fy - float(iy0), 0.0, 1.0);
  float tz = clamp(fz - float(iz0), 0.0, 1.0);

  float c00 = mix(fetchFieldSample(baseIndex, ix0, iy0, iz0), fetchFieldSample(baseIndex, ix1, iy0, iz0), tx);
  float c10 = mix(fetchFieldSample(baseIndex, ix0, iy1, iz0), fetchFieldSample(baseIndex, ix1, iy1, iz0), tx);
  float c01 = mix(fetchFieldSample(baseIndex, ix0, iy0, iz1), fetchFieldSample(baseIndex, ix1, iy0, iz1), tx);
  float c11 = mix(fetchFieldSample(baseIndex, ix0, iy1, iz1), fetchFieldSample(baseIndex, ix1, iy1, iz1), tx);
  float c0 = mix(c00, c10, ty);
  float c1 = mix(c01, c11, ty);
  return mix(c0, c1, tz);
}

float evaluateField(uint baseIndex, vec3 p, const BrickHeader h) {
  return sampleBrickField(baseIndex, p, h);
}

vec3 evaluateNormal(uint baseIndex, vec3 p, const BrickHeader h, float voxelSize) {
  float eps = max(voxelSize * REFINE_EPS, 1e-4);
  float fx1 = evaluateField(baseIndex, p + vec3(eps, 0.0, 0.0), h);
  float fx0 = evaluateField(baseIndex, p - vec3(eps, 0.0, 0.0), h);
  float fy1 = evaluateField(baseIndex, p + vec3(0.0, eps, 0.0), h);
  float fy0 = evaluateField(baseIndex, p - vec3(0.0, eps, 0.0), h);
  float fz1 = evaluateField(baseIndex, p + vec3(0.0, 0.0, eps), h);
  float fz0 = evaluateField(baseIndex, p - vec3(0.0, 0.0, eps), h);
  vec3 n = vec3(fx1 - fx0, fy1 - fy0, fz1 - fz0);
  return (length(n) > 0.0) ? normalize(n) : vec3(0.0, 1.0, 0.0);
}

bool refineSurface(uint baseIndex,
                   vec3 origin,
                   vec3 dir,
                   float ta,
                   float tb,
                   const BrickHeader h,
                   out float tOut) {
  vec3 originWorld = origin + g.renderOrigin;
  float fa = evaluateField(baseIndex, originWorld + dir * ta, h);
  float fb = evaluateField(baseIndex, originWorld + dir * tb, h);
  tOut = ta;
  if (fa * fb > 0.0) {
    return false; // no sign change along this segment
  }
  float a = ta;
  float b = tb;
  float tMid = ta;
  for (int i = 0; i < REFINE_MAX_ITERS; ++i) {
    tMid = 0.5 * (a + b);
    float fm = evaluateField(baseIndex, originWorld + dir * tMid, h);
    if (fm == 0.0) break;
    bool same = (fm * fa) > 0.0;
    if (same) {
      a = tMid;
      fa = fm;
    } else {
      b = tMid;
      fb = fm;
    }
  }
  tOut = tMid;
  return true;
}

uint fallbackMaterialId() {
  return 0u;
}

bool fetchMaterialId(uint linearIndex, BrickHeader h, out uint materialId) {
  uint flags = brickFlags(h);
  uint baseWord = h.matIdxOffset >> 2u;
  if ((flags & BRICK_FLAG_USES4BIT) != 0u) {
    uint wordIndex = baseWord + (linearIndex >> 3u);
    if (wordIndex >= materialIndices.length()) {
      return false;
    }
    uint word = materialIndices[wordIndex];
    uint shift = (linearIndex & 7u) << 2u;
    uint paletteIdx = (word >> shift) & 0xFu;
    uint paletteCount = brickPaletteCount(h);
    if (paletteCount == 0u) {
      materialId = paletteIdx;
      return true;
    }
    if (paletteIdx >= paletteCount || h.paletteOffset == BRICK_INVALID_OFFSET) {
      return false;
    }
    uint paletteBase = h.paletteOffset >> 2u;
    uint paletteIndex = paletteBase + paletteIdx;
    if (paletteIndex >= paletteEntries.length()) {
      return false;
    }
    materialId = paletteEntries[paletteIndex];
    return true;
  } else {
    uint wordIndex = baseWord + (linearIndex >> 2u);
    if (wordIndex >= materialIndices.length()) {
      return false;
    }
    uint word = materialIndices[wordIndex];
    uint shift = (linearIndex & 3u) << 3u;
    materialId = (word >> shift) & 0xFFu;
    return true;
  }
}

// -------------------------------------------------------------------------------------------------
// Queue helpers
// -------------------------------------------------------------------------------------------------

bool dequeuePrimaryRay(out RayPayload ray) {
  for (;;) {
    uint idx = atomicAdd(RayQueueIn.header.head, 1u);
    uint tail = RayQueueIn.header.tail;
    if (idx < tail) {
      uint slot = idx & (RayQueueIn.header.capacity - 1u);
      ray = RayQueueIn.rays[slot];
      return true;
    }
    atomicAdd(RayQueueIn.header.head, uint(0u - 1u));
    if (idx >= tail) return false;
  }
}

bool dequeueSecondaryRay(out RayPayload ray) {
  for (;;) {
    uint idx = atomicAdd(SecondaryQueue.header.head, 1u);
    uint tail = SecondaryQueue.header.tail;
    if (idx < tail) {
      uint slot = idx & (SecondaryQueue.header.capacity - 1u);
      ray = SecondaryQueue.rays[slot];
      return true;
    }
    atomicAdd(SecondaryQueue.header.head, uint(0u - 1u));
    if (idx >= tail) return false;
  }
}

bool dequeueRay(out RayPayload ray) {
  return (dispatch.queueSrc == 0u) ? dequeuePrimaryRay(ray)
                                   : dequeueSecondaryRay(ray);
}

uint reserveMissSlot(uint overflowReason) {
  uint slot = atomicAdd(MissQueue.header.tail, 1u);
  uint capacity = MissQueue.header.capacity;
  if (capacity == 0u) {
    atomicAdd(MissQueue.header.dropped, 1u);
    return 0u;
  }
  uint headSnapshot = MissQueue.header.head;
  if ((slot - headSnapshot) >= capacity) {
    atomicAdd(MissQueue.header.dropped, max(1u, overflowReason));
    return headSnapshot & (capacity - 1u);
  }
  return slot & (capacity - 1u);
}

void enqueueMiss(const RayPayload ray, uint reason) {
  uint slot = reserveMissSlot(reason + 1u);
  MissPayload payload;
  payload.origin     = ray.origin;
  payload.tMin       = ray.tMin;
  payload.direction  = ray.direction;
  payload.tMax       = ray.tMax;
  payload.throughput = ray.throughput;
  payload.padThroughput = 0.0;
  payload.rng        = ray.rng;
  payload.pixelIndex = ray.pixelIndex;
  payload.pathDepth  = ray.pathDepth;
  payload.reason     = reason;
  MissQueue.misses[slot] = payload;
}

void enqueueHit(const RayPayload ray, float tHit, vec3 normal, uint material) {
  uint slot = atomicAdd(HitQueue.header.tail, 1u);
  uint capacity = HitQueue.header.capacity;
  if (capacity == 0u) {
    atomicAdd(HitQueue.header.dropped, 1u);
    return;
  }
  uint headSnapshot = HitQueue.header.head;
  if ((slot - headSnapshot) >= capacity) {
    atomicAdd(HitQueue.header.dropped, 1u);
    slot = headSnapshot;
  }
  slot &= (capacity - 1u);
  HitPayload payload;
  payload.position   = ray.origin + ray.direction * tHit;
  payload.t          = tHit;
  payload.normal     = normal;
  payload.material   = material;
  payload.direction  = ray.direction;
  payload.rng        = ray.rng;
  payload.pixelIndex = ray.pixelIndex;
  payload.pathDepth  = ray.pathDepth;
  payload.throughput = ray.throughput;
  payload.padThroughput = 0.0;
  HitQueue.hits[slot] = payload;
}

// -------------------------------------------------------------------------------------------------
// Debug helpers (single invocation writes per-dispatch diagnostics)
// -------------------------------------------------------------------------------------------------

void recordMacroDiag(ivec3 startCoords,
                     uint startPresent,
                     uint stepCount,
                     ivec3 endCoords,
                     uint endPresent,
                     uint reasonCode) {
  if ((g.flags & FLAG_ENABLE_MACRO) == 0u) return;
  if (gl_GlobalInvocationID.x != 0u || gl_GlobalInvocationID.y != 0u || gl_GlobalInvocationID.z != 0u) return;
  const uint base = 60u;
  if (atomicCompSwap(DBG.dbg[base], 0u, 1u) != 0u) return;
  DBG.dbg[base + 1u]  = uint(startCoords.x);
  DBG.dbg[base + 2u]  = uint(startCoords.y);
  DBG.dbg[base + 3u]  = uint(startCoords.z);
  DBG.dbg[base + 4u]  = startPresent;
  DBG.dbg[base + 5u]  = stepCount;
  DBG.dbg[base + 6u]  = uint(endCoords.x);
  DBG.dbg[base + 7u]  = uint(endCoords.y);
  DBG.dbg[base + 8u]  = uint(endCoords.z);
  DBG.dbg[base + 9u]  = endPresent;
  DBG.dbg[base + 10u] = reasonCode;
}

// -------------------------------------------------------------------------------------------------
// Macro skipping
// -------------------------------------------------------------------------------------------------

bool traverseBrickMicro(const RayPayload ray,
                        float tEnter,
                        float tExit,
                        const BrickHeader h,
                        out float tHit,
                        out vec3 hitNormal,
                        out uint materialId) {
  float t0 = max(tEnter, ray.tMin);
  float t1 = min(tExit, ray.tMax);
  if (t0 > t1) return false;

  vec3 renderOrigin = g.renderOrigin;
  vec3 originWorld = ray.origin + renderOrigin;
  vec3 brickOriginWorld = vec3(h.bx, h.by, h.bz) * g.brickSize;
  vec3 dir = ray.direction;
  if (length(dir) == 0.0) return false;

  vec3 p0World = originWorld + dir * t0;
  vec3 local = (p0World - brickOriginWorld) / g.voxelSize;

  ivec3 voxel = clamp(ivec3(floor(local)), ivec3(0), ivec3(VOXEL_BRICK_SIZE - 1));
  ivec3 step = ivec3(
    (dir.x > 0.0) ? 1 : ((dir.x < 0.0) ? -1 : 0),
    (dir.y > 0.0) ? 1 : ((dir.y < 0.0) ? -1 : 0),
    (dir.z > 0.0) ? 1 : ((dir.z < 0.0) ? -1 : 0)
  );

  vec3 invDir = vec3(
    safeReciprocal(dir.x),
    safeReciprocal(dir.y),
    safeReciprocal(dir.z)
  );
  vec3 absInv = abs(invDir);
  vec3 tDelta = vec3(g.voxelSize) * absInv;

  vec3 nextBoundary;
  nextBoundary.x = (step.x > 0) ? ((float(voxel.x) + 1.0) - local.x) : (local.x - float(voxel.x));
  nextBoundary.y = (step.y > 0) ? ((float(voxel.y) + 1.0) - local.y) : (local.y - float(voxel.y));
  nextBoundary.z = (step.z > 0) ? ((float(voxel.z) + 1.0) - local.z) : (local.z - float(voxel.z));
  nextBoundary = max(nextBoundary, vec3(0.0));

  vec3 tMax = vec3(
    (step.x == 0) ? INF_T : (t0 + nextBoundary.x * absInv.x * g.voxelSize),
    (step.y == 0) ? INF_T : (t0 + nextBoundary.y * absInv.y * g.voxelSize),
    (step.z == 0) ? INF_T : (t0 + nextBoundary.z * absInv.z * g.voxelSize)
  );

  float tCellEnter = t0;
  uint baseWord = h.occOffset >> 3u;
  uint fieldBase = 0u;
  bool fieldReady = brickFieldBase(h, fieldBase);
  bool blockNormalsFlag = ((g.flags & FLAG_FORCE_BLOCK_NORMALS) != 0u) || !fieldReady;

  for (int iter = 0; iter < MICRO_MAX_STEPS && tCellEnter <= t1; ++iter) {
    atomicAdd(TraverseStats.microSteps, 1u);
    uint linear = uint(voxel.x) +
                  uint(voxel.y) * uint(VOXEL_BRICK_SIZE) +
                  uint(voxel.z) * uint(VOXEL_BRICK_SIZE * VOXEL_BRICK_SIZE);
    uint word = baseWord + (linear >> 6u);
    uint bit  = linear & 63u;
    bool occupied = ((OCC.occWords[word] >> bit) & 1ul) != 0ul;

    float tCellExit = min(tMax.x, min(tMax.y, tMax.z));
    if (occupied) {
      bool forceBlock = blockNormalsFlag;
      float tCandidate = tCellEnter;
      vec3 normal = vec3(0.0);
      bool surfaceFound = true;
      if (forceBlock) {
        vec3 absDir = abs(dir);
        if (absDir.x >= absDir.y && absDir.x >= absDir.z) {
          normal = vec3(dir.x > 0.0 ? -1.0 : 1.0, 0.0, 0.0);
        } else if (absDir.y >= absDir.x && absDir.y >= absDir.z) {
          normal = vec3(0.0, dir.y > 0.0 ? -1.0 : 1.0, 0.0);
        } else {
          normal = vec3(0.0, 0.0, dir.z > 0.0 ? -1.0 : 1.0);
        }
      } else {
        float tExitClamped = min(tCellExit, t1);
        float tRefined = tCellEnter;
        surfaceFound = refineSurface(fieldBase,
                                     ray.origin,
                                     dir,
                                     tCellEnter,
                                     tExitClamped,
                                     h,
                                     tRefined);
        if (surfaceFound) {
          tCandidate = tRefined;
          vec3 hitWorld = originWorld + dir * tCandidate;
          normal = evaluateNormal(fieldBase, hitWorld, h, g.voxelSize);
        }
      }
      if (!forceBlock && !surfaceFound) {
        occupied = false;
      } else {
        tHit = tCandidate;
        hitNormal = normal;
        uint matValue;
        if (fetchMaterialId(linear, h, matValue)) {
          materialId = matValue;
        } else {
          materialId = fallbackMaterialId();
        }
        return true;
      }
    }

    if (tCellExit > t1) break;

    if (tMax.x <= tMax.y && tMax.x <= tMax.z) {
      tCellEnter = tMax.x;
      if (step.x == 0) break;
      tMax.x += tDelta.x;
      voxel.x += step.x;
    } else if (tMax.y <= tMax.z) {
      tCellEnter = tMax.y;
      if (step.y == 0) break;
      tMax.y += tDelta.y;
      voxel.y += step.y;
    } else {
      tCellEnter = tMax.z;
      if (step.z == 0) break;
      tMax.z += tDelta.z;
      voxel.z += step.z;
    }

    if (any(lessThan(voxel, ivec3(0))) || any(greaterThan(voxel, ivec3(VOXEL_BRICK_SIZE - 1)))) {
      break;
    }
  }

  return false;
}

// -------------------------------------------------------------------------------------------------
// Main traversal
// -------------------------------------------------------------------------------------------------

void processRay(const RayPayload rayIn) {
  RayPayload ray = rayIn;
  vec3 renderOrigin = g.renderOrigin;
  vec3 rayOriginWorld = ray.origin + renderOrigin;

  float shellEnter, shellExit;
  if (!intersectSphereShell(rayOriginWorld, ray.direction, g.Rin, g.Rout, shellEnter, shellExit)) {
    enqueueMiss(ray, MISS_REASON_SHELL);
    return;
  }

  float tMin = max(ray.tMin, shellEnter);
  float tMax = min(ray.tMax, shellExit);
  if (tMin >= tMax) {
    enqueueMiss(ray, MISS_REASON_SHELL);
    return;
  }

  // Near-surface band to prioritise traversal around the crust
  float tBandMin = tMin;
  float tBandMax = tMax;
  float sea0, sea1;
  if (intersectSphere(rayOriginWorld, ray.direction, g.Rsea, sea0, sea1)) {
    float sea = INF_T;
    if (sea0 >= tMin && sea0 <= tMax) sea = min(sea, sea0);
    if (sea1 >= tMin && sea1 <= tMax) sea = min(sea, sea1);
    if (sea < INF_T * 0.5) {
      float baseBand = 8.0 * g.brickSize;
      float bandBelow = max(baseBand, -g.noiseMinHeight + g.brickSize);
      float bandAbove = max(baseBand, g.noiseMaxHeight + g.brickSize);
      float eps  = 1e-4 * g.brickSize;
      tBandMin = max(shellEnter, sea - bandBelow) + eps;
      tBandMax = min(shellExit, sea + bandAbove);
    }
  }

  float tMacroMin = max(tMin, tBandMin);
  float tMacroMax = min(tMax, tBandMax);

  float tCursor = tMacroMin;
  if (tCursor >= tMax) {
    enqueueMiss(ray, MISS_REASON_ENV);
    return;
  }
  vec3 dir = ray.direction;
  vec3 posStartWorld = rayOriginWorld + dir * (tCursor + BRICK_NUDGE * g.brickSize);
  ivec3 brickCoords = ivec3(floor(posStartWorld / g.brickSize));

  float macroSize = g.macroSize;
  int macroDim = int(g.macroDimBricks);
  bool useMacroSkip = ((g.flags & FLAG_ENABLE_MACRO) != 0u) && (g.macroHashCapacity > 0u) && (macroDim > 0) && (macroSize > 0.0);
  ivec3 macroCoords = ivec3(0);
  if (useMacroSkip) {
    macroCoords = ivec3(
      floorDiv(brickCoords.x, macroDim),
      floorDiv(brickCoords.y, macroDim),
      floorDiv(brickCoords.z, macroDim)
    );
  }

  vec3 invDir = vec3(
    safeReciprocal(dir.x),
    safeReciprocal(dir.y),
    safeReciprocal(dir.z)
  );
  vec3 absInvDir = abs(invDir);
  vec3 tDelta = vec3(g.brickSize) * absInvDir;

  for (int step = 0; step < BRICK_MAX_STEPS && tCursor < tMax; ++step) {
    vec3 cellMinWorld = vec3(brickCoords) * g.brickSize;
    vec3 cellMaxWorld = cellMinWorld + vec3(g.brickSize);
    vec3 samplePosWorld = rayOriginWorld + dir * (tCursor + BRICK_NUDGE * g.brickSize);

    float tx = tCursor + safeNextBoundary(samplePosWorld.x, cellMinWorld.x, cellMaxWorld.x, dir.x);
    float ty = tCursor + safeNextBoundary(samplePosWorld.y, cellMinWorld.y, cellMaxWorld.y, dir.y);
    float tz = tCursor + safeNextBoundary(samplePosWorld.z, cellMinWorld.z, cellMaxWorld.z, dir.z);
    float tBrickExit = min(tx, min(ty, tz));

    // Macro skip inside the loop to avoid spending time in empty coarse tiles.
    if (useMacroSkip) {
      bool skipped = false;
      int macroLoop = 0;
      ivec3 diagStart = macroCoords;
      uint diagStartPresent = macroTileOccupied(macroCoords) ? 1u : 0u;
      ivec3 diagEnd = diagStart;
      uint diagEndPresent = diagStartPresent;
      uint diagSteps = 0u;
      uint diagReason = (diagStartPresent != 0u) ? 0u : 5u;

      if (diagStartPresent == 0u) {
        for (;;) {
          atomicAdd(TraverseStats.macroSkipped, 1u);
          skipped = true;
          diagSteps += 1u;
          if (macroLoop++ >= MACRO_MAX_STEPS) {
            useMacroSkip = false;
            diagReason = 1u; // exceeded guard steps
            break;
          }

          vec3 macroMin = vec3(macroCoords) * macroSize;
          vec3 macroMax = macroMin + vec3(macroSize);
          vec3 macroSample = rayOriginWorld + dir * tCursor;
          float txMacro = (abs(dir.x) < 1e-20) ? INF_T : safeNextBoundary(macroSample.x, macroMin.x, macroMax.x, dir.x);
          float tyMacro = (abs(dir.y) < 1e-20) ? INF_T : safeNextBoundary(macroSample.y, macroMin.y, macroMax.y, dir.y);
          float tzMacro = (abs(dir.z) < 1e-20) ? INF_T : safeNextBoundary(macroSample.z, macroMin.z, macroMax.z, dir.z);
          float tAdvance = min(txMacro, min(tyMacro, tzMacro));
          if (tAdvance < -1e-5) {
            useMacroSkip = false;
            diagReason = 4u; // invalid advance
            break;
          }

          tAdvance = max(tAdvance, 0.0);

          float nextCursor = tCursor + tAdvance + MACRO_STEP_EPS * macroSize;
          if (nextCursor >= tMacroMax) {
            diagReason = 2u; // exited band window
            diagEnd = macroCoords;
            diagEndPresent = 0u;
            recordMacroDiag(diagStart, diagStartPresent, diagSteps, diagEnd, diagEndPresent, diagReason);
            enqueueMiss(ray, MISS_REASON_BAND);
            return;
          }

          tCursor = min(nextCursor, tMax);
          if (tCursor >= tMax) {
            diagReason = 3u; // escaped traversal bounds
            diagEnd = macroCoords;
            diagEndPresent = 0u;
            recordMacroDiag(diagStart, diagStartPresent, diagSteps, diagEnd, diagEndPresent, diagReason);
            enqueueMiss(ray, MISS_REASON_ENV);
            return;
          }

          vec3 macroSamplePos = rayOriginWorld + dir * (tCursor + BRICK_NUDGE * g.brickSize);
          brickCoords = ivec3(floor(macroSamplePos / g.brickSize));
          macroCoords = ivec3(
            floorDiv(brickCoords.x, macroDim),
            floorDiv(brickCoords.y, macroDim),
            floorDiv(brickCoords.z, macroDim)
          );
          diagEnd = macroCoords;
          bool presentNext = macroTileOccupied(macroCoords);
          diagEndPresent = presentNext ? 1u : 0u;
          if (presentNext) {
            diagReason = 0u; // landed on occupied macro tile
            break;
          }

          if (tCursor >= tMacroMax) {
            diagReason = 2u;
            diagEndPresent = 0u;
            recordMacroDiag(diagStart, diagStartPresent, diagSteps, diagEnd, diagEndPresent, diagReason);
            enqueueMiss(ray, MISS_REASON_BAND);
            return;
          }
        }
      }

      recordMacroDiag(diagStart, diagStartPresent, diagSteps, diagEnd, diagEndPresent, diagReason);
      if (useMacroSkip && skipped && diagEndPresent == 1u) {
        atomicAdd(TraverseStats.macroVisited, 1u);
        continue;
      }
    }

    uint brickIdx;
    if (findBrick(brickCoords, brickIdx)) {
      BrickHeader h = BH.headers[brickIdx];
      if (brickHasOccupancy(h)) {
        float tHit;
        vec3 normal;
        uint material;
        if (traverseBrickMicro(ray, tCursor, min(tBrickExit, tMax), h, tHit, normal, material)) {
          atomicAdd(TraverseStats.hitsTotal, 1u);
          enqueueHit(ray, tHit, normal, material);
          return;
        }
      }
    }

    // Advance to next brick along the smallest tMax axis.
    if (tx <= ty && tx <= tz) {
      tCursor = tx;
      brickCoords.x += (dir.x >= 0.0) ? 1 : -1;
    } else if (ty <= tz) {
      tCursor = ty;
      brickCoords.y += (dir.y >= 0.0) ? 1 : -1;
    } else {
      tCursor = tz;
      brickCoords.z += (dir.z >= 0.0) ? 1 : -1;
    }
    atomicAdd(TraverseStats.brickSteps, 1u);
  }

  // Reached the end of the traversal window without hitting a voxel.
  enqueueMiss(ray, MISS_REASON_ENV);
}

void main() {
  for (;;) {
    RayPayload ray;
    if (!dequeueRay(ray)) {
      return;
    }
    processRay(ray);
  }
}
