#version 460

#include "common.glsl"
#include "spherical.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct QueueHeader {
  uint head;
  uint tail;
  uint capacity;
  uint dropped;
};

struct RayPayload {
  vec3  origin;
  float tMin;
  vec3  direction;
  float tMax;
  uint  rng;
  uint  pixelIndex;
  uint  pathDepth;
  uint  flags;
};

layout(set = 0, binding = 10, std430) buffer RayQueueBuf {
  QueueHeader header;
  RayPayload rays[];
} RayQueueIn;

vec3 makeCameraOrigin() {
  vec4 o = g.currViewInv * vec4(0.0, 0.0, 0.0, 1.0);
  return o.xyz;
}

vec3 makeCameraRay(vec2 ndc) {
  vec4 clip = vec4(ndc, 1.0, 1.0);
  vec4 view = g.currProjInv * clip;
  view /= max(view.w, 1e-6);
  vec4 world = g.currViewInv * vec4(normalize(view.xyz), 0.0);
  return normalize(world.xyz);
}

shared uint blockBaseIndex;
shared uint activePrefix[64];

void main() {
  ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
  bool isActive = pix.x < int(g.width) && pix.y < int(g.height);
  uint localIndex = gl_LocalInvocationIndex;

  const uint blockSize = gl_WorkGroupSize.x * gl_WorkGroupSize.y;

  activePrefix[localIndex] = isActive ? 1u : 0u;
  barrier();
  for (uint offset = 1u; offset < blockSize; offset <<= 1u) {
    uint value = 0u;
    if (localIndex >= offset) {
      value = activePrefix[localIndex - offset];
    }
    barrier();
    activePrefix[localIndex] += value;
    barrier();
  }

  uint blockActiveCount = activePrefix[blockSize - 1u];
  if (blockActiveCount == 0u) {
    return;
  }

  if (localIndex == 0u) {
    blockBaseIndex = atomicAdd(RayQueueIn.header.tail, blockActiveCount);
  }
  barrier();

  if (!isActive) {
    return;
  }

  uint localRank = activePrefix[localIndex] - 1u;

  uint pixelIndex = uint(pix.y) * g.width + uint(pix.x);
  vec2 uv = (vec2(pix) + vec2(0.5)) / vec2(float(g.width), float(g.height));
  vec2 ndc = vec2(uv.x * 2.0 - 1.0, 1.0 - uv.y * 2.0);

  vec3 origin = makeCameraOrigin();
  vec3 dir = makeCameraRay(ndc);
  origin -= g.renderOrigin;

  float tMin = 0.0;
  float tMax = g.Rout * 4.0;

  uint capacity = RayQueueIn.header.capacity;
  if (capacity == 0u) return;

  uint slot = blockBaseIndex + localRank;
  if ((slot - RayQueueIn.header.head) >= capacity) {
    atomicAdd(RayQueueIn.header.dropped, 1u);
    return;
  }
  uint idx = slot & (capacity - 1u);
  RayPayload payload;
  payload.origin = origin;
  payload.tMin = tMin;
  payload.direction = dir;
  payload.tMax = tMax;
  payload.rng = pcg_hash(pixelIndex ^ (g.frameIdx * 1664525u));
  payload.pixelIndex = pixelIndex;
  payload.pathDepth = 0u;
  payload.flags = 0u;
  RayQueueIn.rays[idx] = payload;
}
